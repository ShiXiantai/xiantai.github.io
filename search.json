[{"title":"用户名、密码等15个常用的js正则表达式","url":"/2018/09/21/正则表达式/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n用户名、密码等15个常用的js正则表达式\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n**1 用户名正则**\n\n//用户名正则，4到16位（字母，数字，下划线，减号）\n\n\tvar uPattern = /^[a-zA-Z0-9_-]{4,16}$/;\n//输出 true\n\n\tconsole.log(uPattern.test(\"iFat3\"));\n** 2 密码强度正则**\n\n//密码强度正则，最少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符\n\n\tvar pPattern = /^.*(?=.{6,})(?=.*\\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&*? ]).*$/;\n//输出 true\n\n\tconsole.log(\"==\"+pPattern.test(\"iFat3#\"));\n\n**3 整数正则**\n\n//正整数正则\n\n\tvar posPattern = /^\\d+$/;\n//负整数正则\n\n\tvar negPattern = /^-\\d+$/;\n//整数正则\n\n\tvar intPattern = /^-?\\d+$/;\n//输出 true\n\n\tconsole.log(posPattern.test(\"42\"));\n//输出 true\n\n\tconsole.log(negPattern.test(\"-42\"));\n//输出 true\n\n\tconsole.log(intPattern.test(\"-42\"));\n\n**4 数字正则**\n\n可以是整数也可以是浮点数\n\n//正数正则\n\n\tvar posPattern = /^\\d*\\.?\\d+$/;\n//负数正则\n\n\tvar negPattern = /^-\\d*\\.?\\d+$/;\n//数字正则\n\n\tvar numPattern = /^-?\\d*\\.?\\d+$/;\n\tconsole.log(posPattern.test(\"42.2\"));\n\tconsole.log(negPattern.test(\"-42.2\"));\n\tconsole.log(numPattern.test(\"-42.2\"));\n**5 Email正则**\n\n//Email正则\n\n\tvar ePattern = /^([A-Za-z0-9_\\-\\.])+\\@([A-Za-z0-9_\\-\\.])+\\.([A-Za-z]{2,4})$/;\n//输出 true\n\n\tconsole.log(ePattern.test(65974040@qq.com));\n\n**6 手机号码正则**\n\n//手机号正则\n\n\tvar mPattern = /^((13[0-9])|(14[5|7])|(15([0-3]|[5-9]))|(18[0,5-9]))\\d{8}$/;\n//输出 true\n\n\tconsole.log(mPattern.test(\"18600000000\"));\n\n**7 身份证号正则**\n\n//身份证号（18位）正则\n\n\tvar cP = /^[1-9]\\d{5}(18|19|([23]\\d))\\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\\d{3}[0-9Xx]$/;\n//输出 true\n\n\tconsole.log(cP.test(\"11010519880605371X\"));\n\n**8 URL正则**\n\n//身份证号（18位）正则\n\n\tvar cP = /^[1-9]\\d{5}(18|19|([23]\\d))\\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\\d{3}[0-9Xx]$/;\n//输出 true\n\n\tconsole.log(cP.test(\"11010519880605371X\"));\n\n**9 IPv4地址正则**\n\n//ipv4地址正则\n\n\tvar ipP = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;\n//输出 true\n\n\tconsole.log(ipP.test(\"115.28.47.26\"));\n**10 十六进制颜色正则**\n\n//RGB Hex颜色正则\n\tvar cPattern = /^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/;\n//输出 true\n\n\tconsole.log(cPattern.test(\"#b8b8b8\"));\n\n**11 日期正则**\n\n//日期正则，简单判定,未做月份及日期的判定\n\n\tvar dP1 = /^\\d{4}(\\-)\\d{1,2}\\1\\d{1,2}$/;\n\n//输出 true\n\n\tconsole.log(dP1.test(\"2017-05-11\"));\n\n//输出 true\n\n\tconsole.log(dP1.test(\"2017-15-11\"));\n\n//日期正则，复杂判定\n\n\tvar dP2 = /^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$/;\n\n//输出 true\n\n\tconsole.log(dP2.test(\"2017-02-11\"));\n\n//输出 false\n\n\tconsole.log(dP2.test(\"2017-15-11\"));\n\n//输出 false\n\n\tconsole.log(dP2.test(\"2017-02-29\"));\n\n**12 QQ号码正则**\n\n//QQ号正则，5至11位\n\n\tvar qqPattern = /^[1-9][0-9]{4,10}$/;\n//输出 true\n\n\tconsole.log(qqPattern.test(\"65974040\"));\n\n**13 微信号正则**\n\n//微信号正则，6至20位，以字母开头，字母，数字，减号，下划线\n\n\tvar wxPattern = /^[a-zA-Z]([-_a-zA-Z0-9]{5,19})+$/;\n\n//输出 true\n\n\tconsole.log(wxPattern.test(\"RuilongMao\"));\n\n**14 车牌号正则**\n\n//车牌号正则\n\n\tvar cPattern = /^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]{1}[A-Z]{1}[A-Z0-9]{4}[A-Z0-9挂学警港澳]{1}$/;\n//输出 true\n\n\tconsole.log(cPattern.test(\"京K39006\"));\n\n**15 包含中文正则**\n\n//包含中文正则\n\n\tvar cnPattern = /[\\u4E00-\\u9FA5]/;\n//输出 true\n\n\tconsole.log(cnPattern.test(\"42度\"));","tags":["js正则表达式"],"categories":["front-end"]},{"title":"Web基础，JavaScript，JQuery","url":"/2018/08/30/面试题Web基础-JavaScript-JQuery/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\nWeb基础，JavaScript，JQuery\n<!-- more -->\n<The rest of contents | 余下全文>\n\n1.XML和HTML的联系\n\n\tXML：可扩展(自定义)标签语言，标签、属性、标签之间的嵌套关系均可扩展，作用是存储/传输数据\n\tHTML：超文本标签语言，标签、属性、标签之间的嵌套关系均固定(W3C)，作用是显示数据，可以将HTML理解为标签固定的XML\n\n2.JS有哪些内部对象\n\n    String对象、Number对象、Boolean对象、Array对象、Math对象、Date对象、RegExp对象 Function对象\n\n3.JS的外部对象(BOM与DOM)\n\t\n\t由JS的运行环境提供的对象，JS的运行环境是浏览器，也就是由浏览器提供的对象，浏览器提供了两组对象：BOM和DOM。\n\tBOM：浏览器对象模型,用来访问和操纵浏览器窗口,使JavaScript有能力与浏览器\"对话\"，对象的引用是window，window对象是访问BOM和DOM的入口。\n\twindow对象的属性和方法：使用时可以省略window\n\tDocumen：窗口中显示的HTML文档对象。\n\tScreen屏幕：这个属性代表当前浏览器屏幕信息，如分辨率等等。\n\tLocation位置：代表当前浏览器的地址栏，用于切换地址拦。\n\tHistory屏幕：代表浏览器地址栏中的历史记录。\n\tNavagator领航员：包含当前浏览器的元数据信息，如厂商，版本等。\n\tDOM：当网页被加载时，浏览器会创建页面的文档对象模型，用来操作文档，定义了访问和操作HTML文档的标准方法, 应用程序通过对DOM树的操作, 来实现对HTML文档数据的操作。\n\tDOM提供了查找节点、读取节点信息、修改节点信息、创建新节点、删除节点等操作。\n\n4.JS知识补充\n\t\n\t1.JS中没有方法的重载，JS根据方法名调用方法，和参数无关。\n\t2.在方法中，可以使用arguments获取全部的方法参数，没传递的变量，默认值是未定义undefined。\n\t3.arguments对象：arguments对象是一种特殊对象,在函数代码中,表示函数的参数数组，在函数代码中可以使用arguments访问所有参数\n\t4.方法是一个对象的属性，可以任意的替换为新方法。\n\t5.直接声明的函数是window对象的方法，直接声明的变量是window对象的属性。\n\n5.定时器\n\n\t浏览器提供了定时器功能，其底层的本质是线程，定时器是并发执行的，可以在网页中利用定时器处理并发问题。\n\t1：间隔执行定时器：按照一定固定间隔时间执行的方法\n\tWindow提供了两个方法用于处理固定间隔执行\n\tsetInterval()启动定时器，clearImterval()取消定时器。\n\t2：执行一次的定时器：用于处理延迟功能\n\tsetTimeout()启动，clearTimeout()清除。\n\n6.Jquery是什么，JQuery的使用步骤，什么是Jquery对象\n\t\n\tJQuery是一个javaScript框架，最大的特点是利用选择器查找要操作的节点(DOM对象)，并且将找到的节点封装成一个JQuery对象，通过调用Jquery对象提供的方法，来操作底层的节点，这样做可以简化代码，兼容性更好。\n\t引入Jquery的js文件，利用选择器查找要操作的节点，调用jquery对象提供的方法。\n\tjQuery为了解决浏览器的兼容问题而提供的一种封装后的对象描述, jQuery提供的方法都是针对jQuery对象特有的, 而且大部分方法的返回值类型也是jQuery对象, 所以方法可以联缀调用jQuery对象.方法().方法().方法()...\n\tjQuery对象与DOM对象的关系：\n\tjQuery对象本质上是一个DOM对象数组, 它在该数组上扩展了一些操作数组中元素的方法\n\n7.JQuery有哪些选择器\n\t\n\t1.基本选择器：元素选择器，类选择器，id选择器。\n\t2.层次选择器：\n\t3.过滤选择器：根据元素的基本特定定位元素, 常用于表格和列表。\n\t4.内容过滤选择器：根据文本内容定位元素。\n\t5.可见性过滤选择器：根据可见性定位元素。\n\t6.属性过滤选择器：根据属性定位元素。\n\t7.状态过滤选择器：根据状态定位元素。\n\t8.表单选择器：:text  匹配文本框  :password  匹配密码框 等等。\n\t9.子元素过滤选择器： \n","tags":["Web基础，JavaScript，JQuery"],"categories":["interview"]},{"title":"WEB前端JQuery","url":"/2018/08/30/前端JQuery/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\nWEB前端\n<!-- more -->\n<The rest of contents | 余下全文>\n##JQuery\n####什么是JQuery\n- 是一个通过JavaScript代码写的 关于JavaScript的框架\n- 用来简化js代码\n- 可以像css一样通过选择器获取元素\n- 可以快速修改元素的样式\n\n####如何引入jQuery\n- 因为jQuery就是一个js文件 所以引入方式和引入一个普通的js文件一样\n\n\t\t<script type=\"text/javascript\" \n\t\t\tsrc=\"../js/jquery-1.4.2.min.js\"></script>\n####jQuery对象和js对象互相转换\n1. 把js转成jq\n\n\t\t/* 得到js对象 */\n\tvar input = document.getElementById(\"myinput\");\n\t/* 把js对象转成jQuery对象 */\n\t/* $是jQuery单词的缩写  $=jQuery */\n\tvar $jq = $(input);\n\t/* 弹出文本框的value值 */\n\n2. 把jq转成js\n\n\t\t/* 得到jq对象 */\n\tvar $jq = $(\"#myinput\");\n\t/* 把jq转成js对象 */\n\t//第一种写法\n\tvar js1 = $jq[0];\n\t//第二种写法\n\tvar js2 = $jq.get(0);\n\talert(js1.value+\"=\"+js2.value);\n\n###选择器\n####基础选择器\n1. 标签名选择器\n\tvar $div = $(\"div\");\t\n2. id选择器\n\tvar $div = $(\"#id\");\t\n3. 类选择器\n\tvar $div = $(\".class\");\t\n4. 分组选择器\n\tvar $div = $(\"div,#id,.class\");\t\n5. 任意元素选择器\n\tvar $div = $(\"*\");\t\n###层级选择器\n1. $(\"div span\") 匹配div下所有的span元素\n2. $(\"div>span\") 匹配div的所有span子元素\n3. $(\"div+span\") 匹配div相邻的后面的兄弟span元素 \n4. $(\"div~span\") 匹配div后面所有的兄弟span元素\n###层级函数 当得到某个元素对象后 需要获得该元素的相关元素的时候使用\n1. 获取元素的所有兄弟元素\n\t$(\"#abc\").siblings(\"div\");  \n2. 获取元素的哥哥元素\n\t$(\"#abc\").prev(\"div\");\n3. 获取元素的哥哥们元素\n\t$(\"#abc\").prevAll(\"div\");\n4. 获取元素的弟弟元素\n\t$(\"#abc\").next(\"div\"); \n5. 获取元素的弟弟们元素\n\t$(\"#abc\").nextAll(\"div\"); \n###过滤选择器\n1. $(\"div:first\")匹配所有div中的第一个  \n2. $(\"div:last\")匹配所有div中的最后一个  \n3. $(\"div:even\")匹配所有div中的偶数 从0开始\n4. $(\"div:odd\")匹配所有div中的奇数 从0开始\n5. $(\"div:eq(n)\") 匹配所有div中下标等于n的 从0开始\n6. $(\"div:lt(n)\") 匹配所有div中下标小于n的 从0开始\n7. $(\"div:gt(n)\") 匹配所有div中下标大于n的 从0开始\n8. $(\"div:not(.abc)\"  匹配所有div中class值不等于abc\n###内容选择器\n1. $(\"div:has(p)\") 匹配所有包含p标签的div\n2. $(\"div:empty\") 匹配所有空的div\n3. $(\"div:parent\")匹配所有非空的div\n4. $(\"div:contains('abc')\") 匹配包含abc文本内容的div\n###可见选择器\n1. $(\"div:hidden\") 匹配所有隐藏的div\n2. $(\"div:visible\")匹配所有可见的div\n###显示隐藏相关的函数\n1. 让隐藏的元素显示 \n\t$(\"div:hidden\").show();\n2. 让显示额元素隐藏\n\t$(\"div:visible\").hide();\n3. 切换隐藏和显示状态\n\t$(\"#abc\").toggle();\n###属性选择器\n1. $(\"div[id]\") 匹配所有有id属性的div元素\n2. $(\"div[id='abc']\") 匹配有id属性值为abc的所有div\n3. $(\"div[id!='abc']\") 匹配有id属性值不为abc的所有div\n###子元素选择器 \n1. $(\"div:nth-child(n)\") 获取div中第n个子元素 从1开始\n2. $(\"div:first-child\") 获取div中第1个子元素\n3. $(\"div:last-child\") 获取div中最后一个子元素\n###表单选择器\n1. $(\":input\") 匹配所有 文本框 密码框 单选 多选 下拉选 文本域 按钮\n2. $(\":password\") 匹配所有密码框\n3. $(\":radio\")匹配所有单选\n4. $(\":checkbox\")匹配所有多选（复选框）\n5. $(\":checked\")匹配所有被选中的 单选、多选、下拉选\n6. $(\"input:checked\") 匹配所有被选中的 单选、多选\n7. $(\":selected\") 匹配被选中的下拉选\n\n###和页面(DOM)相关\n1. 创建元素\n\tvar div = document.createElement(\"div\");\n\tvar $div = $(\"<div>abc</div>\");\n2. 添加到页面中\n\t$(\"#big\").append($div); //添加到最后面\n\t$(\"#big\").prepend($div);//添加到最前面\n\n3. 插入元素\n\t兄弟元素.after(新元素) 加载兄弟元素的后面\n\t兄弟元素.before(新元素) 加载兄弟元素的前面\n\t\t\t//添加到二哥前面 before\n\t\t\t$(\"h1:contains('二')\").before($h1);\n\t\t\t//添加到二哥的后面 after\n\t\t\t$(\"h1:contains('二')\").after($h1);\n\n4. 删除元素\n- 通过自己删除  $(\"#id\").remove();\n- 先匹配到所有的指定类型元素 从里面删除某些元素 $(\"div\").remove(\"#abc\");\n\n5. 修改元素的样式css\n\t$(\"div\").css(\"color\",\"red\");\n\n6. 属性\n\t$(\"#abc\").attr(\"id\"); 获取id的属性值 \t\n\t$(\"#abc\").attr(\"class\",\"aaa\"); 给元素添加class属性值为aaa\n\n7. 文本\n\t$(\"#abc\").text()  获取文本内容\n\t$(\"#abc\").text(\"啊啊啊\") 赋值文本内容\n8. html\n\t$(\"#abc\").html()  获取文本内容\n\t$(\"#abc\").html(\"<h1>啊啊啊</h1>\") 赋值文本内容","tags":["JQuery"],"categories":["front-end"]},{"title":"前端WEB框架","url":"/2018/08/30/前面Web框架/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\nWEB前端\n<!-- more -->\n<The rest of contents | 余下全文>\n刘国斌 77331283   bjliugb@tedu.cn\n###网站的架构\n- CS：Client Server 客户端和服务端\n\n\t移动客户端：Android和iOS\n\t电脑客户端：windows和linux、Mac OS\n\t客户端是由客户端工程师开发\n\t服务端功能：给客户端提供数据 \n\t应用场景： 京东、淘宝、唯品会\n- BS：Browser Server 浏览器和服务端\n\n\t浏览器\n\t服务端功能： 给浏览器提供数据 和 页面\n\t应用场景： 页游  \n![](web01-1.png)\n- 将来工作 BS和CS架构都会涉及，但是只需要掌握BS架构 CS就会了\n\n###课程介绍\n\n![](web01-2.png)\n###前端课程介绍\n1. HTML ： 用来勾勒出页面的结构和内容(骨架)\n2. CSS ： 用来美化页面 \n3. JavaScript： 让页面呈现动态效果和动态数据的\n4. JQuery：用来简化JavaScript代码的\n\n###HTML\n\tHyper Text Markup Language：超文本标记语言 \n- 什么是超文本：不仅仅是文本，还包括文本的字体颜色，样式 还包括多媒体（图片，音频，视频）\n- html学习内容： 学习有哪些固定的标签，还有标签内部有哪些属性和标签和标签之间的嵌套关系\n\n","tags":["WEB"],"categories":["front-end"]},{"title":"WEB前端JavaScript","url":"/2018/08/30/前端JavaScript/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\nWEB前端\n<!-- more -->\n<The rest of contents | 余下全文>\n##JavaScript  简称JS\n\n\thtml搭建页面结构和内容  CSS用来美化页面  JS给页面添加动态效果或显示动态内容\n\n###JS历史\n\n\t1995年由网景（NetScape）公司发布 LiveScript 同年改名为 JavaScript，和Java没啥关系主要为了蹭热度\n###JS特点\n- 属于脚本语言 不需要编译 由浏览器解析执行\n- JS可以嵌入到Html文件中 \n- JS是基于面向对象语言\n- JS属于弱类型语言  \n###JS优点\n- 交互性： 可以直接和用户进行交互\n- 安全性： JS语言只能访问浏览器内部内容，不能访问浏览器以外内容(指磁盘中的各种数据)\n###如何在html文件中嵌入js代码\n\n\t\t<!-- 1. 在元素的事件中添加js代码 -->\n\t<input type=\"button\" value=\"点我试试\" \n\tonclick=\"alert('第一种引入方式成功！')\">\n\n\n\t<!-- 2. 通过script标签添加js代码  可以写在任意位置-->\n\t\t<script type=\"text/javascript\">\n\t\t\talert(\"第二种引入方式\");\n\t\t</script> \n\n\t<!-- 3.通过单独的*.js文件写js代码 以下方式引入 引入文件后\n\t\t不能在当前script标签体内写js代码  -->\n\t\t<script type=\"text/javascript\" src=\"first.js\">\n\t\t\t//这个位置不能再写js代码\n\t\t</script>\n\n##JavaScript语法\n###数据类型\n1. 数值类型（number）\n2. 字符串类型(string)\n3. 布尔值类型(boolean)\n4. undefined (未定义)\n5. 对象类型  null\n###变量的声明和赋值\n- 因为js属于弱类型语言 声明变量的时候不需要指定类型，直接赋值即可\n\n\tvar x = 18;\n\tvar s = \"abc\";\n\ts = 20;\n\tvar b = true/false;\n\tvar y;\n- 如果变量只声明没有赋值 则此变量的类型为undefined 值也是undefined。\n\n####数值类型 \n- 在js中所有的数值底层都是浮点型， 在使用过程中会自动转换整数或小数\n\t\tint x = 5/2; x=?(在java中结果是2)   \n\t\tvar x= 6/2; 3\n\t\tvar x = 5/2; 2.5\n- NaN（Not a Number）：不是一个数 ，用来判断一个变量是否为数值类型 判断方式通过isNaN()函数判断,当变量不是数的时候为true，是数为false\n\t\t\n\t\tisNaN(20);  false\n\t\tisNaN(\"aaa\"); true\n####字符串\n - 通过单引号或双引号修饰一个字符串，例如：var s1 = 'abc'; var s2=\"abc\";\n\n####布尔值\n- 值为true和false\n####undefined\n- 此类型只有一个值为undefined，变量声明但未定义的话为undefined\n####null\n- null为对象类型的值    var p = null; \n\n###js各种类型间的隐式转换\n1. 数值类型\n- 转字符串： 18->\"18\"     \"abc\"+18   \"abc18\"\n- 转布尔值：  0和NaN转false   其它所有数转true    \n2. 字符串\n- 转数字：  \"18\"->18   \"abc\"->NaN  \"18abc\"->18\n- 转布尔值: \"\"空字符串转成false  其它都是true\n3. 布尔值\n- 转数字： true->1   false->0\n- 转字符串：true->\"true\"    false->\"false\"    \n4. undefined\n- 转数字  NaN     21+undefined= NaN  NaN和任何数值进行运算都得NaN\n- 转布尔值  undefined->false   \n- 转字符串 undefined->\"undefined\"\n5. null\n- 转数字  null->0\n- 转布尔值    null->false \n- 转字符串 null->\"null\"    \"abc\"+null = \"abcnull\"\n\n###测试 在页面中添加两个按钮点击时 弹出 \"66\"+6  和 \"66\"-6 的结果\n\n###运算符\n- js中运算符和Java中的基本一致\n- ==和===：==会在比较两端变量数值之前先将变量类型统一，统一后再比较值.===会先比较类型是否相等如果相等再比较数值如果不等就直接false\n \"666\"==666  true     \"666\"===666  false\n\n- typeof  获取变量的类型    typeof 234234+6 = \"number6\"\n- 除法运算会自动根据结果转换整数还是小数 \n###语句\n包括：if else while do while for switch case\n- 条件如果不是布尔类型会自动转换成布尔类型\n- for 中 把int改成var， js中不支持增强for循环(foreach)\n\n\t\tfor(var i=0;i<10;i++){\n\t\t}\n###函数(方法)\n\npublic String run(String name,int age){\n\t\treturn \"abc\";\n}\n\n- 格式一：\n\t\tfunction 函数名(参数列表){\n\t\t\treturn 18;\n\t\t}\n\t例如：\n\n\t\tfunction fun(name,age){\n\t\t\treturn \"abc\";\n\t\t}\n- 格式二：\n\n\t\tvar 函数名 = function(参数列表){\n\t\t\treturn \"abc\";\n\t\t}\n####和页面元素相关的函数\n1. 得到页面元素对象的函数\n\tvar x = document.getElementById(\"id\");\n2. 获取value值或给value赋值\n\t\n\tvar z = x.value;    x.value=\"abc\";\n3. 给元素添加文本内容\n\t\n\tx.innerText=\"abc\";\t\n4. 给元素添加html代码\n\t\n\tx.innerHTML=\"<h1>abc</h1>\";\n\n### String 内容介绍\nString  数组  日期对象  正则 \n\n####字符串强转成数值\n- parseFloat: 把字符串转成整数或小数\n- parseInt:  把字符串/小数 转成整数\n- Number：等效parseFloat\n\n###String常用Api\n1. 字符串创建的方式\n\n\tvar str1 = \"abc\";\n\tvar str2 = new String(\"abc\");\n2. 转大写和转小写\n\ttoUpperCase()  toLowerCase();\n3. 查找字符串出现的位置\n\n\tstr.indexOf('a')获取a在str中第一次出现的位置\n\tstr.lastIndexOf(\"a\")获取z在str中最后一次出现的位置\n4. 截取字符串\n\tstr.substring(start,[end]);  //end可以省略 \n5. 替换字符串\n\tstr.replace(old,new);\n6. 拆分字符串\n\tstr.split(\":\") a:b:c  [a,b,c]\n\n####数值函数\n1. 四舍五入    num.toFixed(2);//参数表示保留几位小数\n\n####数组相关函数\n1. 创建数组\n\tvar arr1 = [\"刘备\",50,true];\n\tvar arr2 = new Array();//空数组\n2. 数组中添加元素\n\tarr.push(\"小明\");\n\tarr.push(18);\n3. 获取数组中的数据arr[2];\n4. 获取数组长度和修改长度 arr.length arr.length=3;\n5. 数组反转 arr.reverse();\n6. 数组排序 arr.sort();\n7. 默认排序规则：按照每一个字符的unicode编码进行排序，比较完第一个字符比较第二个，把数值当成字符串进行排序\n\n8. 自定义排序：\n\n\tvar arr = [10,5,3,25,22,29,8,18,15]; /* 使用默认排序规则排序 / //arr.sort(); //alert(arr); / 自定义规则 */ function sortfn(a,b){ //return a-b;//升序 return b-a;//降序 } arr.sort(sortfn);\n\n###日期相关函数\n1. 创建时间对象得到客户端时间\n\n\tvar d = new Date();\n\n2. 创建时间对象指定时间 var d2 = new Date(\"2018/08/02 12:38:22\");\n3. 获取和设置时间戳(距1970年1月1号 8：00:00) d2.getTime(); d2.setTime(1000);\n4. 获取时间分量\n\n    -\t/* 从完整时间年月日时分秒中提取时间分量 / \n\t-\tconsole.log(d.getFullYear());//年 \n\t-\tconsole.log(d.getMonth());//月 从0开始 需要+1 \n\t-\tconsole.log(d.getDate());//日 \n\t-\tconsole.log(d.getDay());//星期几 \n\t-\tconsole.log(d.getHours());//小时 \n\t-\tconsole.log(d.getMinutes());//分钟 \n\t-\tconsole.log(d.getSeconds());//秒\n\t-\t / 得到年月日 / \n\t-\tconsole.log(d.toLocaleDateString());\n\t-\t / 得到时分秒 */ \n\t-\t console.log(d.toLocaleTimeString());\n\n###正则表达式\n1. 场景：1. 查找内容 2. 校验文本\n2. . 匹配任意字符（除了换行）\n3. \\w 匹配任意字母、数字、下划线\n4. \\d 匹配任意数字\n5. \\s 匹配任意空白\n6. ^ 开始\n7. $ 结束\n8. 正则表达式的创建方式 var reg1 = /表达式/模式； i忽略大小写 g全局查找 var reg2 = new RegExp(\"表达式\",\"模式\")模式参数可省略 表达式\\需要转义\n9. 相关属性\n\t-   reg.exec(str); //查找内容\t查一次得到一个 没有则返回null \n\t-   reg.test(str); //校验文本\n\t-   str.match(reg);//查找内容 得到所有\n   \t-   str.replace(reg,newStr)//查找内容并替换\n\t\n\n####事件的取消\n- 在元素的事件中如果执行 return false 则取消当前事件\n\n\t\t<a href=\"http://tmooc.cn\" onclick=\"return false\">Tmooc</a>\n###失去焦点事件\n- 失去焦点以文本框为例，当光标离开的时候，此事件触发\n\t<input type=\"text\" onblur=\"\">\n###控制元素的隐藏和显示\n1. display:block/inline/inline-block/none(隐藏 脱离文档流)\n2. visibility：hidden(隐藏 不脱离文档流)/visible（显示） \n\n###自定义对象\n\n\n\t\t/* 通过声明函数的形式声明一个对象 */\n\t\tfunction Person(name,age){\n\t\t//声明属性\n\t\tthis.name=name;\n\t\tthis.age=age;\n\t\t//声明方法\n\t\tthis.run=function(){\n\t\t\talert(\"name=\"+this.name+\" age=\"+this.age);\n\t\t}\n\t\t}\n\t\t//创建对象\n\t\tvar p = new Person(\"貂蝉\",85);\n\t\tp.run();\n\t\t\n\t\t/* 声明空对象 */\n\t\tfunction SuperMan(){\n\t\t}\n\t\t//创建对象 \n\t\tvar sman = new SuperMan();\n\t\t//添加属性\n\t\tsman.name=\"克拉克\";\n\t\tsman.age=18;\n\t\t//添加方法\n\t\tsman.fly = function(){\n\t\t\talert(\"我叫\"+this.name+\"今年\"\n\t\t\t\t\t+this.age+\"岁，我在飞\");\n\t\t}\n\t\t//调用方法\n\t\tsman.fly();\n\t\n\t\t\n\t\t/* 第二种声明对象的方式 */\n\t\t/* 以声明变量的形式创建对象 */\n\t\tvar p = {\n\t\t\t\t\"name\":\"吕布\",\n\t\t\t\t\"age\":25,\n\t\t\t\t\"run\":function(){\n\t\t\t\t\talert(\"name\"+this.name+\" age=\"+this.age);\n\t\t\t\t}\n\t\t}\n\t\t//调用对象的方法\n\t\tp.run();\n\n###DHTML\n- 简介： Dynamic(动态) HTML，不是一门新技术，把HTML，CSS，JavaScript整合到一起得到的一门动态页面技术 \n- DHTML包括： BOM Browser浏览器 Object对象 Model模型 和 DOM Document文档  Object对象 Model模型 \n- BOM： 浏览器对象模型，包括一些和浏览器相关的对象和函数 \n- DOM： 文档对象模型，包括一些和页面相关的对象和函数 \n\n![](web09.png)\n###BOM的相关内容\n####window\n\twindow中所有的属性和函数，调用时可以把window省略掉，window中的属性称为全局属性，函数称为全局函数\n- window的全局函数\n\n\tparseFloat/parseInt() \n\talert();//弹出框\n\tconfirm();//确认框\n\tprompt();//弹出文本框\n\tisNaN();\n- window的全局属性\n1. location（地址）： \n\tlocation.href 可以获取和设置浏览器当前的显示地址\n\t\n\tlocation.reload()  页面刷新\n2. history（历史）：\n\thistory.length 得到当前窗口访问过的页面数量\n\thistory.forward() //访问下一个页面\n\thistory.back() // 访问上一个页面\n\thistory.go(num) 前往某个页面 0代表当前页面，1代表下个页面，2代表下两个页面 -1 代表上一个 -2 代表上两个页面\n3. screen（屏幕）：\n\twidth/height: 获取屏幕的分辨率\n\tavailWidth/availHeight：获取屏幕可用分辨率\n4. navigator（导航、帮助）\n\tnavigator.userAgent 获取浏览器的版本信息\n\n####window相关的事件\n\n1. 点击事件\n2. 加载完成事件\n3. 获取到焦点事件\n4. 失去焦点事件\n\n\t\t/* 窗口点击事件 */\n\t\t/* onclick = function(){\n\t\t\t//alert(\"窗口被点击了\");\n\t\t\tlocation.href=\"http://tmooc.cn\";\n\t\t} */\n\t\t/* 页面加载完成时执行 */\n\t\tonload = function(){\n\t\t\tvar input = document.getElementById(\"ip1\");\n\t\t\tinput.value=\"abc\";\n\t\t}\n\t\t/* 获取和失去焦点事件 */\n\t\tonblur = function(){\n\t\t\tconsole.log(\"失去焦点\");\n\t\t}\n\t\tonfocus = function(){\n\t\t\tconsole.log(\"得到焦点\");\n\t\t}\n####eval()函数\n- 可以将字符串以js代码的形式执行\n\n\n\n####通过js给元素添加css样式\n\n\tdiv.style.css样式属性名称 = \"属性的值\";\n\n###定时器\n- 通过定时器可以实现 每隔一段时间执行某些代码\n\n- var id = setInterval(函数,3000);//每隔3秒执行函数\n- clearInterval(id);//停止定时器\n- setTimeout(函数,2000);//两秒后执行函数\t\n\n###DOM\n- DOM 文档对象模型，学习dom主要掌握如果对html中的标签进行增删改查操作\n####查找元素\n- 通过id查找  document.getElementById(\"id\");\n- 通过标签名查找  document.getElementsByTagName(\"标签名\");\n- 通过元素的name属性查找 document.getElementsByName(\"name属性的值\");\n- 通过元素的class属性查找 document.getElementsByClassName(\"class属性的值\");\n- 获取body元素  document.body\n####通过层级关系查找元素\n1. 获取元素的上级元素 parentElement; \n2. 获取元素的下级内容（包括元素和文本内容和换行） childNodes\n3. 获取元素的兄弟 x.parentElement.childNodes;\n\n###创建元素\n\t\n\tvar h1 = document.createElement(\"h1\");\n\n###添加元素到某个元素里面\n\n\t父元素.appendChild(新元素);\n\n###插入元素到某个元素的上面\n\n\t父元素.insertBefore(新元素,弟弟元素);\n###删除元素\n\t父元素.removeChild(被删除的元素);\n\n\t\n###事件相关\n####事件分类\n1. 鼠标事件： onclick(点击)  onmouseover(鼠标移动到元素上面) onmouseout(鼠标移出元素)  onmousedown(在元素上鼠标按下) onmouseup(在元素上鼠标松手) onmousemove(在元素上移动)\n2. 键盘事件： onkeydown（键盘按下） onkeyup(键盘松开)\n3. 状态改变事件：onchange(value值发生改变的事件) onload（页面加载完成事件） onfocus(获得焦点事件) onblur(失去焦点事件) onsubmit(表单提交事件) onresize(窗口尺寸改变事件)\n####事件绑定\n1. 在元素标签中添加\n\t<input type=\"text\" onkeydown=\"downfn()\">\n- 此种方式添加事件 ，事件函数中的this代表的是window 如果需要用到事件对应的元素可以在标签中调用函数的时候传递过去一个this 此时的this代表元素自身\n2. 动态绑定事件\n\t/* 动态绑定事件 */\n\t\t/* mybtn.onclick = function(){\n\t\t\talert(\"动态绑定成功！\");\n\t\t}\n\t\t */\n\t\tmybtn.onclick = myfn;\n- 动态绑定的事件，事件函数中的this代表事件对应的元素\n\n####Event对象\n- 通过Event对象可以得到和事件相关的信息\n1. 可以通过event得到鼠标点击屏幕的坐标  event.clientX event.clientY\n2. 可以通过event得到键盘按键的编码 event.keyCode\n3. 通过event获得事件源 （事件源指添加事件的元素）\n\n\t/* 通过event得到事件源  存在兼容性问题 \n\t\t有的浏览器支持target 有的支持srcElement\n\t\t通过以下写法可以保证任何浏览器都能正常执行*/\n\t\tvar obj = event.target||event.srcElement;\n\t\talert(\"标签名称：\"+obj.nodeName);\n####事件传递（事件冒泡）\n- 如果同一个区域有多个事件响应，响应的顺序类似气泡，从下往上，也就是从底层元素往上级元素执行，这个过程称为事件传递\n- 如果页面中有多个元素需要添加事件，可以把事件添加在它们共同的上级元素上面，然后获得事件源，通过判断事件源来处理不同的事件\n\n\n","tags":["JavaScript"],"categories":["front-end"]},{"title":"API,SE","url":"/2018/08/30/面试题API-SE/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\nAPI,SE\n<!-- more -->\n<The rest of contents | 余下全文>\nAPI,SE\n1.HashMap与HashTable的区别\n\n\tHashMap为非线程安全的，效率高，HashTable为线程安全的，效率低\n\tHashMap中null可以作为键，可以有一个或多个键对应的值为null，HashTable中key和value都不允许为null\n\tHashMap采用的是Iterator的遍历方式，而HashTable采用的则是一种古老的Enumeration迭代器遍历方式\n\t哈希值的使用不同, HashTable直接使用对象的hashCode  而HashMap重新计算hash值\n\tHashTable中的hash数组默认大小是11 增长方式是old*2+1  HashMap中的hash数组默认是16 而且一定是2的指数\n\n2.ArrayList，LinkedList，vector的区别和特性\n\t\n\tArrayList:用数组实现；存储空间连续分布 ；查找基于数组索引操作，速度快性能好；增删操作基于数组扩缩容，速度慢性能差。\n\tLinkedList:用链表实现；存储空间分散分布 ；查找基于链表上下指针（两端顺着指针链向中间找），速度慢，尤其链表中部查找慢；增删操作基于链表指针重建，速度块性能好，尤其首尾增删块。\n\tArrayList和vector都是基于数组实现的查询效率高，增删效率低，ArrayList是非线程安全的而vector是线程安全的，因此ArrayList效率比vector效率高\n\n3.String与StringBuilder，StringBuffer的区别\n\t\n\tString:       final修饰的不可被继承，不可变字符串，重写了equals\n\tStringBuilder: 变长字符串，线程不安全，效率高，没有重写equals\n\tStringBuffer:  变长字符串，线程安全的，效率低，没有重写equals\n\n4.简述“==”和“equals”的区别以及为什么我们要重写equals\n\n\t对于引用类型而言，”==”判断的是地址，即：两个引用是否指向同一个对象 对于大部分引用类型而言，equals是基于”==”进行判断的，因此这使得equals没有太大的意义，因此，在实际开发中，我们需要根据具体的业务要求重写equals方法，例如：String重写了equals 判断的是两个字符串的内容是否完全一致。\n\n5.Collection和Collections的区别\n\n\tCollection是集合类的上级接口，继承于它的接口主要有Set和List\n\tCollections是针对集合类的一个工具类，它提供了一系列静态方法实现针\n\t对各种集合的搜索，排序，线程安全化等操作\n\n6.HashMap工作原理\n\n\tHashMap工作原理：\n\t1.通过key的hashcode 进行算列算法——》找对应的散列桶\n\t2.对桶中所有K-V对的K进行equals \n\t\t--如果有为true的说明为同一个key——》替换value\n\t\t--如果都为false则在此桶对应的链表中追加元素\n\t3.hashcode不同但是散列算法计算出的对应桶\n\t\tequals判断一定为false\n\t\t-->散列桶 影响性能；\n\n7.队列和栈的区别\n\t\n\t队列：java.util.Queue 队列，用于储存一组元素，但是存取元素必须遵循先进先出原则\n\t栈：存放一组元素，存取必须遵循先进后出原则  一般应用与操作的可追溯性(后退功能)\n\t双缓冲队列   解决并发效率低的问题  存取时的互斥问题\n\tBlockingQueue<String> messageQueue = new LinkedBlockingQueue<String>();\n\n8.重写equals方法和hashcode方法的规则\n\n\t当两个key的hashcode值一样，意味着他们在散列桶(HashMap中维护的数组)的相同位置，但若着两个key  equals比较结果不true，则在HashMap中就会形成链表，这样的情况多了HashMap的查询性能会降低很多。所以应当妥善处理作为Key元素的类的equals方法与hashcode方法的重写\n\t一致性：应当与equals方法保持一致，即：当两个对象equals比较为true时，hashcode方法返回的数字必须相同，反过来则不是必须的，但应当尽量保证两个对象若hashcode方法返回的数字相同时equals比较也为true,否则在HashMap中会出现链表影响性能查询\n\t稳定性：在参与equals比较的属性值没有发生过变化的前提下多次调用hashcode方法返回的数字不能变化。  \n\n9.常见的异常，异常的分类\n\n\t异常分为\n\t检查异常(编译异常)和\n\t非检查异常(运行异常)RuntimeException\n\t常见的异常：\n\tNullPointerException ：当某对象的引用为null，调用该对象的方法时就会产生空指针异常\n\tClassCastException：类造型异常，假设有类A和类B(A不是B的子类或父类)，O是A的实例，那么当强制将O构造为类B的实例时抛出，该异常经常被称为强制类型转换异常\n\tIndexOutOfBoundsException：下标越界异常，当访问某个序列的索引值小于0或大于等于序列大小时，抛出该异常\n\tClassNotFoundException：找不到该类异常，当应用试图根据字符串形式的类名构造类，而遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常\n\n10.IO流的概述\n\n\t流的分类：按数据方向：输入流和输出流；按数据类型：字节流和字符流。\n\t常用的IO流：\n\t字符流：Reader：BufferedReader，InputStreamReader，FileReader\n\t        Writer：BufferedWriter，OutputStreamWriter，PrintWriter，FileWriter\n\t字节流：InputStream：FileInputStream，BufferedInputStream\n\t        OutputStream：FileOutputStream，BufferedOutputStream\n\t因为在硬盘上的所有文件都是以字节的形式进行传输或者保存的，包括图片等内容。但是字符流只是在内存中才会形成的，所以在开发中，字节流使用广泛。只要是处理存文本数据，就要有限考虑使用字符流，除此之外都是用字节流。","tags":["API,SE"],"categories":["interview"]},{"title":"Servlet-JSP","url":"/2018/08/30/面试题Servlet-JSP/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\nServlet-JSP\n<!-- more -->\n<The rest of contents | 余下全文>\n\n1.有哪些服务器，CS与BS的区别\n\t\n\t服务器：本质是一个软件，它能够用来运行其他软件，它和浏览器对等平级。\n\t常见的服务器有：Tomcat,JBoss,WebLogic,WebSphere。\n\tCS：客户端服务器程序，客户端需要单独开发及安装。\n\tBS：浏览器服务器程序，用浏览器充当客户端，不需要单独开发。\n\n2.什么是HTTP协议，如何通讯，数据格式是什么，常见的错误\n\n\tHTTP协议：是由W3C规定的一种规范，约定了浏览器和服务器之间如何通讯以及通讯的数据格式。\n\t如何通讯：建立连接，发送请求，接受响应，关闭连接，一次请求需要一次连接，尽量减少服务器的压力。\n\t数据格式：\n\t\t\t  1.请求数据包（浏览器-->服务器）：请求行，请求头，实体内容。\n\t          2.响应数据包（服务器-->浏览器）：状态行，消息头，实体内容。\n\t404：找不到资源  405：方法声明有误  500：类名有误.方法内有误\n\n3.Servlet的运行原理\n\t\n\tServlet是Sun推出的用于在服务器端处理HTTP协议的组件。\n\t其特点是保存在服务端，满足Sun的规范，它可以动态的拼任何资源(网页，图片，文档等)。\n\t\t1.浏览器与服务器建立连接,\n\t\t2.浏览器将请求数据进行打包 \n\t\t3.浏览器给服务器发送请求\n\t\t4.服务器将浏览器请求拆包\n\t\t5.服务器自动创建request和response对象(每次请求都会新创建)\n\t\t6.通信组件根据web.xml路径找到项目实例化Servlet对象(调用service方法 传入request和response) 7.Servlet调用request和response \n\t\t8.response将响应数据传给通信组件 \n\t\t9.通信组件将数据打包\n\t\t10.发送数据给浏览器  \n\t\t11.浏览器将数据拆包 \n\t\t12.断开连接\n\n4.Servlet类的层次结构，HttpServlet的结构\n\t  \n\tSun这样设计的目的是为了给程序员更多的选择空间，doXXX()中抛异常是为了强制让程序员重写它，一般重写protected void service()，并且去掉super.service，\n\t目的是避免调用doXXX(),避免抛异常。\n\n5.get和post请求的区别\n\n\tGet：采用路径传参，参数在传递过程可见，隐私性差，只能传递少量参数。\n\tPost：是实体内容传参，参数在传递过程不可见，隐私性好，传参没有限制。\n\t默认的请求方式是get请求，通常在查询时用get，因为查询时只需要传入少量条件，保存时用Post，因为保存时一般需要传入较多的数据。\n\n6.解决请求方式的中文乱码问题的三种方法\n\t\n\t1. get/post：让servlet接收乱码String, 用iso8859-1将其还原程byte,再用utf-8将其转成String  (new String(bytes, “utf-8”)) 优点：万能  缺点：麻烦\n\t2. get：在server.xml第65行, 加URIEncoding=\"utf-8\" 优点：简单 缺点：只能针对请求方式为get\n\t3. post： 在获取请求参数前, 加req.setCharacterEncoding(\"utf-8\") 优点：简单 缺点：只能针对请求方式为post\n\n7.Servlet的生命周期\n\n\t1加载：容器通过类加载器使用Servlet类对应的文件来加载Servlet.\n\t2.创建：通过调用Servlet的构造函数来创建一个Servlet实例\n\t3.Servlet初始化：tomcat在实例化Servlet后, 会立刻调用init方法, 用这个方法给Servlet初始化(预置)一些数据\n\t4.处理客户请求：service()方法给服务器发送请求并接收服务器的响应 \n\t5.卸载：destory() tomcat正常关闭时, 会自动调用此销毁方法, 让Servlet释放其占用的资源, 在此方法内通常删除或重置一些数据\n\t1) 默认第一次访问Servlet时会创建并初始化它\n\t2) 可以修改成启动tomcat时就创建并初始化它 \n\t   在<servlet></servlet> 内设置<load-on-startup>1<load-on-startup>\n\t   1代表在当前项目中此Servlet创建时初始化的顺序\n\t3) 对于某个类型的Servlet来说, 第1、2、4步只会执行一次, 第3步可以执行多次, 因此某个类型的Servlet在tomcat内只有一个实例, 即单例\n\n8.重定向和转发的区别\n\n\t都是解决2个WEB组件之间的跳转问题，WEB组件：Servlet、JSP\n\t重定向：二次请求，地址改变，2个组件使用2个request，不能通过他们共享数据，可以重定向到项目之外的组件。\n\t转发：一次请求，地址不变，2个组件共用1个request，可以通过request共享数据，只能转发给项目内部的组件。\n\t转发的过程：获取转发器，实现转发。转发之后, 地址栏地址不会发生变化, 原因是转发的过程是发生在服务器内部的, 浏览器并不知道。\n\trequest.getRequestDispatcher(uri).forward(request,response);\n\t一般查询时使用转发，增，删，改后重定向到查询页面。\n\n9.config和context的区别，典型的使用场景\n\t\n\tConfig：config和Servlet是1对1的关系，服务器初始化Servlet前会给它先创建一个config对象，每个Servlet都会有一个对应的config对象。\n\tContext：context和Servlet是1对多的关系，服务器启动时会自定创建唯一的一个context，所有Servlet公共的数据存入context。\n\tConfig典型的使用场景：1.假设要做一个网页游戏, 要限制在线人数2.在用户登录时判断是否已经达到了上限maxOnline，3.该参数应该是可以配置的, 并且仅仅是在登录的Servlet中使用, 因此使用config即可\n\tContext典型的使用场景：1.项目中包含很多查询功能, 如查询员工, 部门；2.这些查询功能一般都有分页；3.每页显示的行数(size)是需要可配置4.由于该参数多个功能都要共用, 所以要使用context读取\n\tContext的特殊用法：\n\t1.可以在程序运行的任何阶段用它来存取变量\n\t2.其存储的变量可以在多个Servlet间共用  案例：统计网站流量\n\n10.Cookie和Session的区别及用途\n\n\tCookie保存在浏览器上，默认浏览器关闭，Cookie失效，存储数据量小，只能存储字符串，服务器压力小，但安全性低，一般数据存入Cookie，。\n\tSession保存在服务器上，默认30分钟未访问，Session失效，存储数据量大，存储的数据格式没有限制，访问量大的时候服务器压力大，但安全性高，重要数据存入Session。\n\t用途：因为多个请求之间无法通过request共享数据，多个Servlet之间无法通过config共享数据，而且服务器里只有一个context，存储同名的数据有冲突，所以要使用cookie和session，多个请求之间可以共享这2个对象中的数据，多个Servlet之间可以共享这2个对象中的数据，服务器会给每一个浏览器创建一套cookie和session。由于HTTP是无状态协议（服务器没有记住浏览器），cookie和session是用来管理状态的（让服务器记住浏览器），用来证明浏览器访问过服务器。\n\n11.WEB-INF的作用\n\n\t由于浏览器访问服务器，获取并加载一个网页的过程中，包含了多次请求；WEB-INF具有保护功能，放在其内部的资源受到保护，避免被直接访问，必须通过转发访问。所以，如果JSP不放在WEB-INF下，则别人可以直接访问它；由于我们采用MVC模式，jsp数据来源于Servlet，直接访问它会报错；将它放在WEB-INF下就是要保护它，从而避免报错。\n\t注：静态资源(css,img...)是浏览及加载HTML时直接访问的，不存在转发，所以不能将他们放在WEB-INF下，否则就访问不到了。\n\n12.JSP有哪些内置对象，作用分别是什么\n\n\tJSP有9个基本内置对象，都是Jsp页面翻译后的Servlet类中建立的\n\trequest浏览器请求，此请求会包含来自get/post请求的参数\n\tresponse服务器返回给浏览器的响应\n\tout用来传送回应的输出\n\tconfig Servlet的构架部件\n\tpage JSP网页本身\n\tapplication Servlet正在执行的内容\n\tsession 与请求有关的会话期\n\tpageContext 管理网页的属性\n\texception 针对错误网页，未捕获的例外\n\n13.JSP和Servlet的区别和联系\n\n\tJSP：Sun公司制定的一种服务器端动态页面技术的组件规范, JSP是一个以\".jsp\"为后缀的文件,在该文件中,主要是HTML和少量的Java代码。\n\tJSP是Servlet技术的拓展, 本质上是Servlet的简单方式，更强调应用的外表表达。Servlet和JSP最主要的不同点在于：Servlet的应用逻辑是在Java文件中，并且完全从表示层的HTML里分离开来，而JSP是Java和HTML，可以组合成一个扩展名为.jsp的文件，JSP侧重于视图，Servlet主要控制逻辑\n\tJSP被JSP引擎翻译后的源代码文件默认继承了HttpJspBase, 而抽象类HttpJspBase继承自抽象类HttpServlet, 因此JSP被翻译后可以看成是Servlet\n\n14.动态Include和静态Include的区别（JSP）\n\n\tInclude指令的作用：在JSP页面转换成Servlet时, 能够将其他文件包含进来, 可以包含JSP文件也可以是静态的HTML文件，通过该语句能方便的在每个JSP页面中包含导航栏, 版权声明, logo等\n\t动态INCLUDE用jsp:include动作实现<jsp:include page=”head.jsp”/>它总是会检查所含文件中的变化, 适用于包含动态页面, 并且可以带参数, 各个文件分别先编译, 然后组合成一个文件; \n\t静态INCLUDE用include伪码实现, 定不会检查所含文件的变化, 适用于静态页面<%@include file=”include.html” %> 先将文件的代码被原封不动的加入到主页面从而组合成一个文件, 然后再进行编译, 此时不允许有相同的变量\n\t执行时间上：静态INCLUDE是在翻译阶段执行  动态INCLUDE实在请求处理阶段执行\n\t引入的内容不同：引入静态文本(html.jsp), 在JSP页面被转化成servlet之前和它融合到一起, 动态INCLUDE引入执行页面或servlet所生成的应答文本\n\n15.EL和JSTL表达式的作用和联系\n\n\t由于JSP中嵌套的大量Java代码增加了页面内容的复杂度, 使得页面不够整洁, 不方便代码的维护, 为此Sun公司制定了JSP标签(类似于html标签)来代替java代码, Apache组织开发的一套标签库被Sun公司整合后, 称为标准标签库(JSP Standard Tag Library 即JSTL) 配合EL表达式, 以达到减轻JSP文件的复杂度, 方便维护JSP文件的目的\n\tEL表达式是一套简单的计算规则, 用于给JSP标签的属性赋值, 也可以直接用来输出表达式也可以脱离标签单独使用，使用EL表达式可以1.访问Bean的属性  2.输出简单的运算结果  3.获取请求参数。\n\t常见的标签：\n\t<c:forEach var...>,<c:if var...>,<c:url var...>,<c:choose var...>,<c:when var...>\n\n16.MVC开发模式\n\n\tMVC模式：MVC是经典常见的用户界面设计模式, 是代码分层思想：\n\t\t1.M(Model)模型: 职责是负责业务逻辑，包含：业务数据和业务处理逻辑，比如实体类、Dao、Service都属于模型层。\n\t\t2.V(View)视图: 职责是负责显示界面和用户交互(收集用户信息)。\n\t\t3.C(Controller)控制器: 控制层, 用来处理请求, 进行调度, 使用它可以降低代码的耦合度,便于团队开发及维护。\n\t将原来一个WEB组件所做的事情, 拆分成2个组件一起做, 其中Servlet处理java部分的逻辑,JSP负责展现数据。\n","tags":["Servlet-JSP"],"categories":["interview"]},{"title":"WEB前端CSS","url":"/2018/08/30/前端CSS/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\nWEB前端\n<!-- more -->\n<The rest of contents | 余下全文>\n###CSS\n- 美化页面的技术\n- Cascading 层叠 Style 样式 Sheet 表 ： 层叠样式表，CSS用于美化html页面，html可以理解成盖房子，CSS相当于装修\n\n###CSS的引入方式\n1. 内联样式：在标签内部通过 style属性添加样式，弊端：只能作用于一个元素，不能复用，几乎不使用\n\n\t\t<div style=\"color: red;border: 1px solid green;\">我是一个div</div>\n\t\t<span style=\"color: purple;border: 1px solid pink\">我是一个span</span>\n \n2. 内部样式：在head标签内部通过 style子标签添加样式，好处：可以在本页面内复用样式，弊端：不能多个页面复用同一样式 ，工作中此种方式用的不多，但是学习的时候使用内部样式，主要是方便演示\n\n\t\n\t\t<style type=\"text/css\">\n\t\t\t/* 标签名选择器 */\n\t\t\th3{\n\t\t\t\tcolor: blue;\n\t\t\t\tborder: 2px solid yellow;\n\t\t\t}\n\t\t</style>\n\n3. 外部样式：样式代码写在单独的*.css文件中，通过link标签引入到某个html页面中，好处：样式可以复用在多个页面中\n\n\t\t<link rel=\"stylesheet\" href=\"demo01.css\">\n\t\tcss文件：\n\t\t@charset \"UTF-8\";\n\n\t\tp{\n\t\t\tcolor: red;\n\t\t\tbackground-color: green;\n\t\t}\n\n###三种引入方式的优先级\n- 如果三种引入方式作用的样式不同则全部生效\n- 如果三种引入方式作用的样式相同则按照下面的优先级规则来决定到底哪个生效\n\n1. 内联优先级最高\n2. 内部和外部 后执行会覆盖先执行的\n\n###CSS的选择器\n####基础选择器\n1. 标签名选择器  \n- 应用场景：当需要对页面中所有的某一种标签设置相同效果的时候\n\t\t标签名{\n\t\t\t样式名称:值;\n\t\t\t样式名称:值;\n\t\t}\n2. id选择器\n- 通过标签的id属性找到对应的标签\n- 应用场景：当需要对页面中的某一个元素设置样式的时候使用\n\n\t\t#标签id{\n\t\t\t样式名称:值;\n\t\t\t样式名称:值;\n\t\t}\n3. 类选择器\n- 通过标签的class属性找到对应的标签\n- 应用场景：当需要对页面中的多个元素设置样式的时候使用\n\n\t\t.class{\n\t\t\t样式名称:值;\n\t\t\t样式名称:值;\n\t\t}\n####其它各种选择器\n1. 属性选择器\n- 通过标签内部指定属性查找对应的标签\n\n\t\t标签名[属性名=\"属性值\"]{\n\t\t\t样式名称:值;\n\t\t\t样式名称:值;\n\t\t}\n2. 派生选择器(后代选择器)\n- 通过多个标签之间的上下级关系查找子元素和孙子元素和。。。。所有后代元素\n\t\t\n\t\t基础选择器 基础选择器 基础选择器{\n\t\t\t样式名称:值;\n\t\t\t样式名称:值;\n\t\t}\n3. 子元素选择器\n- 通过多个标签之间的上下级关系查找子元素。\n\n\t\t基础选择器>基础选择器>基础选择器{\n\t\t\t样式名称:值;\n\t\t\t样式名称:值;\n\t\t}\n4. 分组选择器\n- 分组选择器可以把多种选择器通过逗号连接到一起，给多个选择器设置相同的样式\n\t\th3,p,.d1,#abc,#bcd{\n\t\t\tcolor:red;\n\t\t}\n\n5. 伪类选择器\n- 用于选择元素的状态\n1. visited：访问过的状态\n2. link：未点击状态\n3. hover：鼠标悬停状态\n4. active：鼠标点击时的状态\n\n- 使用方式：\n\t\t\t/* 访问过的状态 */\n\t\t\ta:visited {\n\t\t\tcolor: red;\n\t\t}\n\t\t\t/* 未点击状态 */\n\t\t\ta:link {\n\t\t\tcolor: yellow;\n\t\t}\n\t\t\t/* 鼠标悬停状态 */\n\t\t\ta:hover {\n\t\t\tcolor: blue;\n\t\t}\n\t\t\t/* 鼠标点击时的状态 */\n\t\t\ta:active {\n\t\t\tcolor: pink;\n\t\t}\n\n6. 任意元素选择器\n- 如果需要给页面中所有的元素设置相同的样式可以使用此选择器\n\n\t\t*{\n\t\t\t样式名称:值;\n\t\t\t样式名称:值;\n\t\t}\n\n\n####如果多个选择器设置相同样式的效果时，作用范围越小优先级越高\n\n###CSS中常用的属性\n- 已经接触的属性 color（字体颜色）background-color(背景颜色) border（边框）\n\n#### 元素的宽高：\n1. 块级元素的默认高度为内容高度，默认宽度为父元素的宽度\n2. 行内元素的默认宽高为内容的宽高\n- 只能修改块级元素的宽高，不能修改行内元素的宽高\n####设置元素的颜色\n\n\t\t/*1. 通过颜色名称赋值 red yellow green\n\t\t blue pink purple white black orange gray*/\n\t\t/*2. 6位16进制赋值 每两位表示一个颜色 红 绿 蓝   */\n\t\t/* background-color: #ff00ff; */\n\t\t/*3. 3位16进制赋值 每一位表示一个颜色  */\n\t\t/* background-color: #00f; */\n\t\t/*4. 通过3位 10进制赋值 每个取值0-255  */\n\t\t/* background-color:rgb(255,255,0); */\n\t\t/*5. 4位10进制赋值 第四位代表透明度取值0-1 */\n\t\tbackground-color: rgba(0,255,0,0.5);\n####设置元素的背景图片\n\n\t\t/* 设置背景图片 */\n\t\tbackground-image: url(\"../imgs/a.jpg\");\n\t\t/* 设置背景图片的大小 参数为宽和高  */ \n\t\tbackground-size: 100px 100px;\n\t\t/* 设置背景图片不重复 */\n\t\tbackground-repeat: no-repeat;\n\t\t/* 设置背景图片的位置 left center right top bottom \n\t\t第一个参数代表水平 第二个参数代表垂直*/\n\t\t/* background-position: right center; */\n\t\t/* 通过百分比控制位置 */\n\t\tbackground-position:90% 90%;\n\n\n\n###盒子模型\n####外边距\n- 元素距离父元素或相邻兄弟元素的距离称为外边距\n- 赋值方式：\n\n\t\t/* margin: 40px; 四个外边距都是40px */\n\t\t/* margin: 20px 50px; 上下20 左右50 */\n\t\t/* margin: 0 auto; 水平居中 */\n\t\tmargin: 10px 30px 60px 90px;/* 顺时针 上右下左 */\n- 块级元素：上下左右都生效\n- 行内元素：只有左右生效 上下不生效\n- 外边距粘连问题： 当元素的上边缘和父元素的上边缘重合的时候，子元素的上外边距会带着父元素一起移动，通过在父元素中添加 overflow:hidden;解决。\n- 上下外边距取最大值，左右外边距相加\n####边框\n\tborder: 粗细(像素值) 边框的样式(solid) 颜色\n\t/* border: 10px inset purple; */\n\t\tborder-bottom:5px solid yellow;\n\t\tborder-left:5px solid pink;\n\t\tborder-top:5px solid green;\n\t\tborder-right:5px solid black;\n\t\tborder-radius:55px;/*圆角 值越大越园  */\n- 块级元素： 上下左右边框全部生效，而且边框都会占显示区域\n- 行内元素： 上下左右边框全部生效，但是只有左右边框才会占显示区域，上下不占显示区域（不会增加元素自身的高度）\n\n####内边距\n- 内容距离边框的距离\t\n- 给元素添加内边距会影响元素的宽高\n- 移动元素内的子元素几种方式？ 两种：1. 给大的添加内边距（大的所占宽高会跟着改变） 2. 给小的添加外边距\n- 移动元素内的文本的时候几种？ 一种：只能给大的添加内边距。\n- 块级元素：内边距四个方向都生效，而且都会影响元素的显示范围\n- 行内元素：内边距四个方向都生效，左右影响显示范围，上下不影响显示范围\n\n####块级元素和行内元素关于盒子模型的总结\n1. 块级元素：可以设置宽高，外边距全部生效 并且影响元素的所占宽高, 边框四个方向都生效，并且影响元素的所占宽高，内边距全部生效，并且影响元素所占的宽高\n2. 行内元素：不可以设置宽高，外边距左右生效，上下不生效，边框都生效，上下不影响所占高度，内边距都有效果，左右影响所占宽度 上下不影响所占高度\n###元素所占宽度计算公式\n宽高为100*200 左外边距10 右外30  边框5px 左内8px 右内2px\n\n100+10+30+5*2+8+2\n左外边距+左边框+左内边距+元素宽度+右内边距+右边框+右外边距\n\n###文本相关的属性\n\n\t\t/* 文本相关属性 */\n\t\t/* 文本水平对齐方式 center/left/right */\n\t\ttext-align: center;\n\t\t/* 文本修饰  none 没有 \n\t\tunderline 下划线\n\t\toverline 上划线\n\t\tline-through 删除线*/\n\t\ttext-decoration: line-through;\n\t\t/* 文本颜色 */\n\t\tcolor: red;\n\t\t/* 行高  通常让文本垂直居中的时候使用行高 */ \n\t\tline-height: 100px;\n\t\t/* 文本阴影   4个参数\n\t\t1. 阴影颜色 \n\t\t2和3是阴影的偏移值  \n\t\t4. 阴影的模糊度 值越小越清晰 0是不模糊*/\n\t\ttext-shadow: #0f0 -15px 15px 1px;\n\n####字体相关属性\n\n\t\t/* 字体相关属性 */\n\t\tfont-size: 20px;\n\t\t/* 字体粗细属性  normal 不加粗\n\t\t\tbold 加粗\n\t\t\tlighter 比普通细一些\n\t\t */\n\t\tfont-weight: lighter;\n\t\t/* 字体样式  可以设置多个值通过逗号分隔，以此检测\n\t\t哪个生效用哪个 */\n\t\tfont-family: \"楷体\";\n\t\t/* 设置斜体 */\n\t\tfont-style: italic;\n\n###溢出设置 \n- 指子元素显示范围超出父元素范围时的设置\n\n\t\t/* visible(默认 超出显示)\n\t\thidden: 超出不显示\n\t\tscroll:超出滚动显示  */\n\t\toverflow: hidden;\n###元素显示方式\n- block： 块级元素默认的显示方式，独占一行，可以修改宽高\n- inline：行内元素的默认显示方式，共占一行，不可以修改宽高\n- inline-block:行内块，共占一行 并且可以修改宽高\n\n###元素的定位\n####position定位\n#####静态定位（文档流定位）（默认）\n- 元素如果是块级元素则默认从上到下排列，如果是行内元素则从左向右排列\n- 设置方式： position:static;\n#####相对定位\n- 相对于元素初始的位置，通过left/right/top/bottom让元素做位置的偏移\n- 元素不会脱离文档流\n- 场景：当元素需要从当前位置做位置偏移的时候，并且不希望其它元素跟着移动时使用此定位\n#####绝对定位\n- 会脱离文档流 后面有元素的话会顶上来\n- left/right/top/bottom 做位置偏移，相对于谁？ 1. 相对于窗口(没有祖宗或有祖宗但是没有做非static定位) 2. 相对于祖宗元素(有祖宗并且有某个祖宗做了非static定位，如果都做了，则就近原则)（如果仅仅是为了给子元素做位置的参考一般都使用relative）\n- 场景：当元素需要相对于某个祖先元素或窗口做位置偏移的时候，并且不再占用原来的位置时使用此定位方式\n#####固定定位\n- 固定在窗口的某个位置，不会随着内容位置改变而改变\n- 脱离文档流，left/right/top/bottom 坐标相对于窗口\n####浮动定位\n- 元素脱离文档流，元素在当前所在行内 左侧或右侧浮动，当撞到父元素边框或浮起来的兄弟元素边缘的时候\n- 如果所有浮动的元素一行装不下会自动换行，但是如果有凸出的元素会有卡住的效果\n- 如果元素浮动则后面的元素会往上顶(因为浮动会脱离文档流)，如果不希望后面的元素往上移动，则需要在后面紧邻的元素上添加clear属性设置both/left/right,禁止元素 两边/左/右 有浮动的元素。\n- 如果元素的所有子元素全部浮动，并且元素没有设置高度，此时自动识别的高度为0，可以通过添加 overflow:hidden; 让元素能够识别出浮动后子元素的高度\n- 应用场景：当多个纵向排列的元素需要改成横向排列的时候 使用浮动定位\n- 练习： demo08.html 页面中添加一个无序列表把列表项改成横向排列\n####行内元素的垂直对齐方式\n- 默认对齐方式为基线对齐 vertical-align：baseline\n- top/middle/bottom\n\n###CSS的三大特性\n1. 继承性：子元素可以继承父元素的部分属性，只能继承color/font-开头/text-文本相关/line- 此类型的属性，不仅仅子元素继承所有的后代元素都会继承\n- 如果元素自身所带的样式和继承的冲突则以自身所带样式为准，如：h标签的字体大小，超链接的文本颜色和文本下划线\n2. 层叠性：通过不同的选择器可以多次指向同一个元素，如果设置的样式不同则全部生效，如果多个选择器设置的样式相同，则根据CSS的第三特性优先级来决定\n3. 优先级：\n- 直接选中优先级高于间接选中(继承属于间接选中)\n- 如果相同选择器，则后执行的覆盖前面的\n- 不同选择器，作用范围越小 优先级越高    id>class>标签名>继承\n###CSS定位\n####Position\n- position：static，静态定位（文档流定位）， 从上到下 从左向右\n- relative，相对定位：不脱离文档流，上右下左相对于元素初始位置\n- absolute，绝对定位：脱离文档流，相对于窗口或祖先元素\n- fixed，固定定位：脱离文档流，相对于窗口，固定在窗口的某个位置\n####浮动定位\nfloat:left/right; 元素会在当前所在行内左侧或右侧浮动\n- 脱离文档流\n- 如果后面的元素不想顶上去 添加 clear:left/right/both\n- 如果元素所有子元素全部浮动的话 内容高度识别为0 通过添加overflow：hidden解决","tags":["CSS"],"categories":["front-end"]},{"title":"Spring-Mybatis-AJAX","url":"/2018/08/30/面试题Spring-Mybatis-AJAX/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\nSpring-Mybatis-AJAX\n<!-- more -->\n<The rest of contents | 余下全文>\n\n1.Spring是什么，特点是什么\n\t\n\tSpring是个Java企业级应用的开发框架，是个开源的，轻量级的应用开发框架，目的是为了简化企业级应用开发，并通过POJO为基础的编程模型促进良好的编程习惯。POJO对象：传统Java对象(满足JavaBean规范的Java对象)\n\t特点是：\n\t简化开发：spring对常用的API做了简化，比如对jdbc做了简化，我们使用spring jdbc来访问数据库，就不再需要考虑获取连接，关闭连接了。\n\t管理对象：spring提供了一个容器，可以帮我们管理对象与对象之间的关系，这样一来，对象之间的耦合度降低了，方便了代码的维护。\n\t集成：spring可以集成其他的一些框架，比如Mybatis。\n\n2.如何利用Spring容器创建对象\n\n\tSpring容器是spring框架中的一个核心模块，用于管理对象之间的关系。\n\t\t1.利用无参构造器，启动容器，调用容器的getBean方法。\n\t\t2.静态工厂方法，调用类的静态方法来创建对象。\n\t\t3.实例工厂方法，调用对象的方法来创建对象。\n\n3.什么是IOC和DI\n\t\n\tIOC：控制反转，对象之间的依赖关系交给容器来创建。\n\tDI：依赖注入，容器通过调用对象提供的set方法或者构造器来建立对象之间的依赖关系。IOC是目标，DI是手段。\n\t优点：IOC或者DI把应用的代码量降到最低，它使应用容易测试，最小的代价和最小的侵入性使松散耦合得以实现。\n\n4.Spring Bean的作用域和生命周期的管理方法\n\n\tSpring beans是那些形成Spring应用的主干java对象，它们被spring容器初始化，装配和管理。这些beans通过容器中配置的数据创建。\n\tSrping的作用域：默认情况下，针对一个bean的配置，spring容器只会创建一个实例(既作用域为单例的singleton)，可以设置scope属性值为prototype，此时，会创建多个实例。\n\tSpring容器从XML文件中读取bean的定义，并实例化bean；spring根据bean定义填充所有的属性。\n\tSpring容器的生命周期：初始化方法通过init-method属性指定，销毁方法通过destroy-method属性来指定，也有相对应的注解：@PostConstruct和@PreDestroy，这两个注解来至javax.annotation包，使用之前要导入包。\n\t注：只有作用域为单例的bean销毁方法才会执行。\n\n5.什么是SpringMVC模式与SpringMVC的五大组件及执行原理\n\n\tMVC模式是常见的用户界面设计模式，Spring Web MVC是Spring提供的Web界面MVC组件，利用这个组件可以简化WEB界面的开发。\n\tSpringMVC组件：DispatcherServlet(前端控制器)(controller)，HandlerMapping，Controller(处理器)(Model)，ModelAndView，ViewResolver(视图解析器)。\n\t\t1.DispatcherServlet收到请求后, 依据HandlerMapping的配置, 调用相应的Controller来处理。\n\t\t2.Controller将处理结果封装到ModelAndView对象, 然后将该对象返回给DispatcherServlet来处理。注：ModelAndView对象包含有两部分数据, 一是处理结果, 另外还包含有视图名(就是一个字符串, 比如\"hello\")。\n\t\t3.DispatcherServlet依据ViewResolver的解析, 调用相应的视图对象(比如jsp)来生成相应的页面。\n\n6.从控制器传输数据到JSP的方式\n\n\t利用ModelAndView传输数据：如果需要将控制器中的传输到JSP页面，只需要将控制器方法的返回值设置成ModelAndView即可。其中，方法中的model代表发送到JSP界面的数据，view表示使用哪个JSP作为显示界面。\n\t利用HttpServletResuest传输数据：可以在控制器方法参数上注入HttpServletResuest对象，再利用这个对象的setAttribute方法将数据共享到JSP。\n\t两种方式各有好处：\n\t\t1.HttpServletResuest方式：紧耦合，控制器方法紧紧绑定了Servlet API。紧耦合的时候，只能在Web容器中进行测试！但是可以调用Servlet底层的API。\n\t\t2.返回ModelAndView方式：松耦合，控制器与Servlet API无关，可以脱离Web容器单独测试，可以方便的实现与平台无关的测试。\n\t控制器向浏览器发送数据可以利用ModelMap传递数据：\n\t只需要在控制器方法上添加ModelMap参数就可以简洁的向用户界面传递数据。\n\n7.从浏览器向控制器传送数据的三种方式\n\n\tSpring MVC Web请求提交数据到控制器有下面几种方式：\n\t\t1.使用HttpServletRequest获取：在控制器方法上使用HttpServletRequest作为参数，在运行期间Spring MVC自动参数注入HttpServletRequest，在request上直接使用getParamter方法获取参数值。缺点：数据的编码，数据类型都需要手工处理，Servlet与控制器紧耦合，不方便独立测试。优点：可以直接访问Servlet底层API，可以获取通讯的底层详细信息，如读取请求头信息。\n\t\t2.使用@RequestParam注解：使用控制器参数接受表单数据，控制器方法参数名与表单中输入框name属性一直，SpringMVC就自动将表单数据解码并且转换数据类型然后注入到变量中。\n\t\t3.使用自动机制封装成Bean对象：Spring提供值对象方式传递表单参数，值对象用于封装用户名和密码。\n\n8.SpringMVC处理异常的两种方式\n\n\t软件的底层出现的异常抛到表现层就必须处理，Spring提供了三种处理异常的方式。\n\t\t1.使用SpringMVC提供的简单异常处理器SimpleMappingExceptionResolver：添加异常处理界面；添加异常处理器配置，配置异常类型与错误界面的对应关系；在控制器中抛出异常时候，就转发到异常处理界面。\n\t\t2.注解异常处理@ExceptionHandler：SpringMVC提供了在控制器内部处理异常的注解@ExceptionHandler，可以在控制器内部处理异常。\n\n9.Spring与Mybatis的整合\n\n\tMybatis：Mybatis是开源的支持普通SQL查询，存储过程和高级映射的优秀持久层框架，封装了几乎所有的JDBC代码和参数的手工配置以及结果集的检索，使用简单的XML或注解做配置和定义映射关系，可以实现POJO对象与数据库之间的映射访问。\n\tMyBatis提供了mybatis-spring API，这个API可以将Mybatis整合到Spring，利用Spring IOC容器管理Mybatis的组件，可以简化Mybatis的使用和管理。\n\n10.Mybatis的基本原理\n\n\t1.SqlSessionFactory读取配置文件(SqlMapConfig.xml)主要包含dataSource和映射文件路径\n\t2.通过配置文件中的映射路径找到对应的映射文件\n\t3.创建预编译的statement 存放到Map里(key是sql的id)\n\t4.通过SqlSessionFactory创建SqlSession对象\n\t5.SqlSession调用相应的sql方法(第一个参数为映射文件中sql语句对应的id)\n\t6.依据sql语句对应的id获取对应的statement, 然后执行该对象的相应方法\n\t7.如果是查询, 会封装成相应的对象, 或者是对象的集合\n\t返回Map类型的结果\n\t\t1.mybatis会将查询到的结果存放到Map对象里(一条记录对应一个Map对象, 其中字段名做为key, 字段值作为value)\n\t\t2.接下来, 再将Map对象中的数据放到实体对象里面\n\n11.Mapper映射器是什么\n\t\n\tMapper映射器就是符合Mybatis特定要求的接口, Mybatis会依据这些接口生成相应的实现对象，这些接口符合映射文件的要求：\n\t\t1.方法名必须与sql语句的id一样\n\t\t2.方法的返回类型与sql语句的返回类型一致\n\t\t3.方法的参数类型与sql语句的参数类型一致\n\t\t4.此外, 映射文件的namespace必须等于Mapper映射器(即要写这些接口的完整的名称)\n\n12.表的列名与实体属性不一致的解决办法\n\n\t默认情况下，Mybatis根据查询结果列名自动映射到结果对象的同名Bean属性，如果不一致，会有null值出现。当数据库表的列名与查询结果对象的属性不一致时候，可以采用别名映射和采用ResultMap映射。\n\n13.什么是扫描器对象，MapperScannerConfigurer\n\n\tMybatis-Spring提供了一个自动创建Mapper接口匿名子类实例的扫描器MapperScannerConfigurer，这个Bean在实例化的时候，会自动将指定包中Mapper接口创建为Bean对象。\n\t原理：在Spring容器初始化的时候，会自动初始化扫描器MapperScannerConfigurer对象，这是扫描器会扫描指定包中的全部接口，并且自动创建此接口的匿名实例（反射）。有了这个扫描器，就可以直接从Spring中获取Mapper接口的匿名实例，直接访问其方法操作数据库了。\n\n14.什么是AJAX\n\n    ajax(asynchronous javascript and xml)：是一种用来改善用户体验的技术, 其实质是利用浏览器提供的一个特殊的对象(XMLHttpRequest, 也可以称之为ajax对象)异步地向服务器发送请求, 服务器返回部分数据,浏览器利用这些数据对当前页面做部分更新。 整个过程, 页面无刷新, 不打断用户的操作。异步的是指这个对象在向服务器发送请求时,浏览器不会销毁当前页面, 用户仍然可以对当前页面做其它操作。\n\n15.AJAX的常用属性，方法，事件\n\n\tXMLHttpRequest 对象是浏览器内嵌的API，他提供了与与服务器通讯的功能，其常用属性和方法如下：\n\t属性：status：服务器响应状态码：200,404,500...\n\t      readyState：通讯过程状态码：0 1 2 3 4 (尚未初始化-正在发送请求-\n\t                 请求完成-请求成功正在获取数据-数据接收成功)\n\t      responseText：服务器返回的文本数据。\n\t方法：open(请求方式，URL)准备发起对服务器的请求\n\t      send()向服务器发送请求\n\t时间：onreadystatechange:通讯状态变化事件，当代表通讯状态的readyState\n\t     发生变化时，执行的事件方法。\n\t通常将XMLHttpRequest对象简称为：XHR\n\n16.AJAX的开发步骤\n\t\n\t1.创建ajax对象，var xhr=new XMLHttpRequest();\n\t2.利用open方法准备请求，xhr.open('get','check_uname.do')\n\t                             xhr.open(‘post’,url)\n\t     利用AJAX发送POST请求时，必须多一步设置HTTP请求头才能支持POST。\n\t     xhr.setRequestHeader('content-type',' application/x-www-form-urlencoded');\n\t3.绑定通讯状态变化事件，当通讯状态readyState并且响应状态status为200时候表示服务器正常发送了数据，利用responseText获取服务器发回来的数据。\n\t    xhr.onreadystatechange = function(){};\n\t4.用send方法发起请求，xhr.send(null)，xhr.send(param).\n\t    利用AJAX技术可以在不更新页面的情况下与服务器进行交换数据，其经典使用场景：表单数据检查，自动完成等功能。\n\n17.什么是JSON\n\t\n\tJSON(JavaScript Object Notation)：是AJAX通讯中最常用的数据格式，服务器端将数据封装为JSON字符串，客户端将JSON字符串解析为JS对象。\n\tJSON字符串：符合JSON语法的字符串var str=’{“id”:1,”name”:”Tom”}’.\n\tJS中提供了两个API方法，可以将符合JSON语法的字符串转换成JS对象。\n\tvar obj=eval(‘(’+str+’)’);  var obj=JSON.parse(str);\n\n18.JSON关键点总结，利用JSON交换数据\n\t\n\tJSON：用于声明JS对象的语法。\n\tJSON字符串：符合JSON语法的字符串。\n\tJSON字符串可以通过eval和JSON.parse转换为JS对象。\n\t利用JSON交换数据：在AJAX开发中为了将服务器端的数据发送到客户端浏览器,经常的做法是将数据序列为JSON字符串,然后将JSON字符串发送到客户端浏览器, 最后客户端浏览器在收到数据时候转换为JS对象,并且读取其信息\n\t利用JSON API转换Java对象到JSON字符串更加简洁方便，常用的API有Jackson-databind和json-lib ，导入JSON API。\n\n19.JQuery对AJAX的支持，常用的两种方式\n\t\n\tJQuery提供了非常简便的AJAX客户端调用支持，常用方法有：\n\t$.ajax({url:请求路径，type:请求方式，data:请求参数，dataType：服务器返回的数据类型，success:服务器处理正常对应的回调函数，error:服务器出错对应的回调函数，async:true(缺省)当值为false时发送同步请求})；\n\t$.getJSON(url,参数,callback)，$.post(url,参数,callback).\n\n20.什么是AOP，Aspect切面，AOP的常用用途\n\n\tAOP：面向切面编程，是一种编程技术，允许程序模块化横向切割关注点，面向切面编程可以不改变原有软件的逻辑情况下，为软件加入扩展功能。Spring AOP的底层是基于(JDK反射的)动态代理实现的。 \n\tAspect切面：Spring内嵌支持AOP，AOP的核心就是切面，它将多个类的通用行为封装成可重用的模块，该模块含有一组API提供横切功能。根据需求不同，一个应用程序可以有若干切面，在Spring AOP中，导入AspectJ包，切面通过带有@Aspect注解的类实现。\n\t常用用途：\n\t\t1.性能审计\n\t\t2.异常跟踪\n\t\t3.事物处理\n\tSpring事物处理：声明式事物处理，无需编码，只需要使用注解声明事物的边界即可，AOP是非常好的编程事物的替代方案。默认情况下，Spring声明事务的方法，在相互调用的时候，事务会自动传播整合为一个事务过程。\n\t编程步骤：\n\t\t1.在spring-mybatis.xml文件中配置事物管理器\n\t    2.配置注解事物支持\n\t           <tx:annotation-driven transaction-manager=”txManager”/>\n\t    3.使用事物注解标注业务层：@Transactional注解将业务层方法\n\t            看做一个事物，如果有异常抛出，则回滚到初始状态。\n\n21.各种拦截编程的区别\n\n\tSpring MVC拦截器、Servlet Filter过滤器、Spring AOP都是横截面编程\n\tServlet Filter过滤器：可以拦截任何的WEB URL请求（*.jsp,*.js,*.css,*.html），如登陆以后才能看到图片(防盗链)。\t\n\tSpring MVC拦截器：拦截Spring MVC的WEB URL请求。\n\tSpring AOP：拦截对业务层或数据层的请求。\n\n22.两种Spring容器的初始化方法\n\t\n\t1.DispatcherServlet：只使用Spring MVC，则DispatcherServlet即可。\n\t2.ContextLoaderListener：在过滤器的init方法中使用监听器初始化Spring容器，可以替代DispatcherServlet初始化功能，该方法必须与ContextLoaderListener配合才能正常获取Spring容器对象ctx，在web.xml配置Listener.\n\tpublic void init(FilterConfig cfg) throws ServletException {\n\tWebApplicationContext ctx=\n\tWebApplicationContextUtils.getWebApplicationContext(cfg.getServletContext());}\n\n23.两种Spring Bean对象的获取方式\n\n\t1.注入Bean：当前Bean被Spring管理的情况下，可以使用注入。\n\t2.getBean：当前对象不被Spring管理，则需要getBean。\n\t    \n24.简述什么是反射，反射机制提供的功能\n\n\t对于任意一个类，我们可以动态获取它的所有属性和方法，对于任意一个对象，我们都可以动态的调用它的任意一个属性和方法，对于这种动态获取类的信息以及动态调用对象属性和方法的功能称为反射机制。\n\t提供的功能：\n\t1运行时判断任意对象的所属类\n\t2运行时构造任意类的对象\n\t3运行时判断和调用对象的成员变量和方法\n\t4生成动态代理\n","tags":["Spring-Mybatis-AJAX"],"categories":["interview"]},{"title":"常见的几种设计模式","url":"/2018/08/30/面试题常见的几种设计模式/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n常见的几种设计模式\n<!-- more -->\n<The rest of contents | 余下全文>\n\n单例模式\n\n定义：\n\n\t确保一个类只有一个实例，而且自动化实例化并向整个系统提供这个实例\n满足要素：\n\n\t\t1.私有的构造方法  \n\t\t2.指向自己实例的私有静态引用  \n\t\t3.以自己实例为返回值的静态的共有的方法\n\t单利模式根据自己实例化对象时机的不同分为两种：一种是饿汉式单例，一种是懒汉式单例。饿汉式单例在单例类被加载时，就实例化一个对象交给自己的引用，而懒汉式在调用取得实例化方法的时候才会实例化对象\n\n单例模式的优点：\n\n\t\t1.在内存中只有一个对象，节省内存空间  \n\t\t2.避免频繁的创建销毁对象，可以提高性能  \n\t\t3.避免对共享资源的多重使用  \n\t\t4.可以全局访问\n\n适用场景：\n\n\t\t1.需要频繁实例化然后销毁的对象  \n\t\t2.创建对象时耗时过多或者耗资源过多，但又经常用到的对象 \n\t\t3.有状态的工具类对象  \n\t\t4.频繁访问数据库或文件的对象 \n\n单例模式注意事项：\n\n\t\t1.只能使用单例类提供的方法取得单例对象，不要使用反射，否则将会实例化一个新对象  \n\t\t2.不要做断开单例类对象与类中静态引用的危险操作  \n\t\t3.多线程使用单例共享资源时，注意线程安全问题\n\n工厂方法模式\n\n定义：\n\n\t定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类\n\n工厂模式根据抽象程度的不同分为三种：\n\n\t简单工厂模式(也叫静态工厂模式)、工厂方法模式、抽象工厂模式。工厂模式是编程中经常用到的一种模式。\n优点：\n\t\n\t可以使代码结构清晰，有效地封装变化，在编程中，产品类的实例化有时候是比较复杂和多变的，通过工厂模式，将产品的实例化封装起来，使得调用者根本无需关心产品的实例化过程，只需要依赖工厂即可得到自己想要的产品\n\t对于调用者屏蔽具体的产品类。如果使用工厂模式，调用者只关心产品的接口就可以了，至于具体的实现，调用者根本无需关心，即使变更了具体的实现，对于调用者来说没有任何影响\n\t降低耦合度，产品类的实例化通常是很复杂的，它需要依赖很多的类，而这些类对于调用者来说根本无需知道，如果使用了工厂方法，我们需要做的仅仅是实例化好产品类，然后交给调用者使用，对于调用者来说，产品所依赖的类都是透明的\n\t工厂模式依靠抽象架构的，它把实例化产品的任务由实现类完成，扩展性比较好，也就是说，当需要系统有比较好的扩展性时，可以考虑工厂模式，不同的产品用不同的实现工厂组装\n\n抽象工厂模式\n\n定义：\n\n\t为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类\n抽象工厂模式与工厂方法模式的区别：\n\n\t抽象工厂模式是工厂方法模式的升级版本，他用来创建一组相关或相互依赖的对象，他与工厂方法模式的区别就在于，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则是针对的多个产品等级结构，在编程中，通常一个产品结构，表现为一个接口或者抽象类，也就是说，工厂方法模式提供的所有产品都是衍生自同一个接口或抽象类，而抽象工厂模式所提供的产品则是衍生自不同的接口或对象\n\n\t在抽象工厂模式中，有一个产品族的概念，所谓的产品族，是指位于不同产品等级结构中功能相关联的产品组成的家族，抽象工厂模式所提供的一系列产品就组成一个产品族；而工厂方法所提供的一系列产品称为一个等级结构\n抽象工厂模式的优点：\n\t\n\t除了具备工厂方法模式的优点外，最主要的优点就是可以在类的内部对产品族进行约束，所谓的产品族，一般或多或少的都存在一定的关联，抽象工厂模式就可以在类内部对产品族的关联关系进行定义和描述，而不必专门引入一个新的类来进行管理\n缺点：\n\t\n\t产品族的扩展将是一件十分费力的事情，如果产品族中需要增加一个新的产品，几乎所有的工厂都需要进行修改，所有使用抽象工厂模式时，对产品等级结构的划分是非常重要的\n\t无论是简单工厂模式，工厂方法模式，还是抽象工厂模式，他们都属于工厂模式，在形式和特点上也是极为相似的，他们的最终目的都是为了解耦，因此，在使用工厂模式时，只需要关心降低耦合度的目的是否达到了\n\n原型模式\n\n定义：\n\t\n\t用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象\n\n原型模式主要用于对象的复制，它的核心就是原型类Prototype，Prototype类只需要具备两个条件：\n\n\t1.实现Cloneable接口，就是在运行时通知虚拟机可以安全地在实现了此接口的类上使用clone方法，在Java虚拟机中，只有实现了这个接口的类才可以被拷贝，否则运行时会抛出CloneNotSupportedException异常\n\t2.重写Object类中的clone方法，在Java中，所以类的父类都是Object类，Object类中有一个clone方法，作用是返回对象的一个拷贝，但是其作用域prototype类型的，一般的类无法调用，因此，Prototype类需要将clone方法的作用域改为public类型的\n\n 原型模式的优点及适用场景：\n\n\t使用原型模式创建对象比直接new一个对象在性能上要好的多，因为Object类中的clone方法是一个本地方法，它直接操作内存中的二进制流，特别是复制大对象时，性能的差别非常明显。使用原型模式的另一个好处是简化对象的创建，使得创建对象就像我们再编辑文档时复制粘贴一样简单\n原型模式的注意事项：\n\n\t使用原型模式复制对象不会调用类的构造方法。因为对象的复制是通过Object类的clone方法来完成的，它直接在内存中复制数据，因此不会调用类的构造方法。不但构造方法的代码不会执行，甚至连访问权限都对原型模式无效。单例模式中，只要将构造方法的访问权限设置为private型，就可以实现单例，但是clone方法直接无视构造方法的权限，所以，单例模式与原型模式是冲突的，在使用时要特别注意\n浅拷贝：\n\t\n\tObject类中的clone方法只会拷贝对象中的基本数据类型，对于数据，容器对象，引用对象等都不会拷贝，这就是浅拷贝\n深拷贝：\n\t\n\t如果要实现深拷贝，必须将原型模式的数组，容器对象，引用对象等另行拷贝\n\t发生深拷贝的有java中的8种基本类型以及他们的封装类型，另外还有String类型，其余都是浅拷贝\n\n\n","tags":["常见的几种设计模式"],"categories":["interview"]},{"title":"数据库和JDBC","url":"/2018/08/30/面试题数据库和JDBC/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n数据库和JDBC\n<!-- more -->\n<The rest of contents | 余下全文>\n数据库和JDBC\n\n\t1.关系型数据库\n\t2.什么是内连接，外连接，自连接\n\t3.在数据库的条件查询中如何优化速度\n\t4.数据库中主键、外键的作用\n\t5.索引的优点和缺点是什么\n\t6.主键和索引的区别\n\t7.什么叫视图\n\t8.简述truncate，delete，drop之间的区别\n\n1.JDBC的开发步骤\n\t\n\t1：加载驱动，告诉它用哪个数据库厂商提供的实现类Class.forName(“”)\n\t2：添加配置参数：URL\n\t3：创建连接，Connection con = DriverManager.getConnection(“”);\n\t4：创建Statement或者PreparedStatement声明\n\t5：执行sql，获取ResultSet结果集，运行结果集的处理(遍历获取数据等等)\n\t6：关闭连接，释放资源 \n\n2.连接池的工作原理\n\t\n\t创建连接池后，它会自动初始化一批(初始化连接数)连接，这些连接的状态都是空闲态；\n\t调用连接池获取连接的方法，它会返回一个连接，并将此连接标记为占用态；\n\t调用连接关闭的方法，是将其归还给连接池，状态变为空闲态，内容清空；\n\t连接池发现连接快不够用(最小空闲连接)时，会再次初始化一批(每次增加连接数)空闲连接；\n\t连接池发现内部有太多(最大空闲连接数)的空闲连接时，会将一批(每次增加连接数)连接关闭(保留最小连接数)；\n\t当连接池内占用连接达到数据库极限(最大连接数)时，下次请求连接池会让其等待。\n\n3.statement和PreparedStatement的区别\n\n\tStatement适合执行静态(无条件)sql，statement是直接发送sql语句到数据库，事先没有进行预编译，这样会导致恶意注入sql的语句出现问题\n\tPreparedStatement适合执行动态(有条件)sql，preparestatement会将sql进行预编译，当sql语句要重复执行时，数据库会调用以前编译好的sql，所以preparestatement在性能方面会更好，preparestatement在执行sql时，会对传人的参数进行强制类型转换，以保证数据格式与底层数据格式一致\n\n4.什么是事务管理\n\n\t事务是一组原子操作单元，一般指要做或所做的事情\n\t特性：\n\t原子性：事物是一个完成的过程，要么都成功，要么都失败\n\t一致性：事务完成前后数据保持一致，既收支平衡\n\t隔离性：一个事务处理对另外一个事务没有影响，事务在处理过程中不能被外界访问\n\t持久性：事务一旦达成，便永久生效\n\n5.分页查询\n\n\t1.假分页(内存分页)：第一次查询时查出所有的数据，然后存入内存(List)，第N次查询时，直接从内存(List)中取数，特点第一次查询慢，后面快，耗内存，只适合数据量极少的项目。\n\t2.真分页(物理分页)：每次查询都是从数据库中取出一页(N条)数据，基于分页的SQL实现分页查询，特点每次查询速度一样，节约内存，适合所有项目。\n\t1.Oracle分页的SQL：\n\tselect  *  from(\n\t    select  t.*,rownum  r  from(\n\t        Select  *  from  emps  order  by  empno\n\t    )  t\n\t)  where  r  between  11  and  20\n\t2.Mysql分页的SQL\n\tSelect  *  from  emps  prder  by  empno\n\tLimit  11,10\t(第十一条记录开始，查询10条记录)\n\n","tags":["数据库和JDBC"],"categories":["interview"]},{"title":"线程","url":"/2018/08/30/面试题线程/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n线程\n<!-- more -->\n<The rest of contents | 余下全文>\n\n1.线程的两种方法和区别\n\n\tThread：1.继承Thread,2.重写run方法,3.创建线程对象，调用start方法\n\tRunnable接口创建线程： 1.实现Runnable接口，实现run方法 2.创建接口的子类实例  3.创建线程对象，将接口的子类实例作为线程参数  4.调用start方法。启动线程\n\t两种方法的区别：\n\n\t\t1.第一种由于要集成Thread，而java又是单继承原则，这就导致当前类不能再集成其他类，很多时候会在实际开发中出现继承冲突问题。\n\t\t2.由于线程内部重写run方法定义了当前线程要执行的任务，这就导致了线程与任务有一个强耦合关系，不利于线程的重用。\n\t\t3.使用Runnable接口创建线程的好处是，当前的类可以继承于其他的类，也可以继承其他的接口。\n\n2.sleep()和wait()的区别\n\t\n\tsleep属于Thread类中的方法，表示一个线程进入了睡眠状态，等待一定时间后，自动醒来进入到可运行状态，不会马上进入到运行状态，因为线程调度机制恢复线程的运行也需要时间，一个线程对象调用了sleep方法之后，并不会释放它所持有的对象锁，所以也就不会影响其他线程的运行，但在sleep的过程中有可能被其他对象调用它的interrupt()产生InterruptedException异常，如果程序不捕获这个异常，线程就会异常终止，进入到terminated，如果捕获了这个异常，程序就会继续执行catch语句块(可能还有finally语句块)以及以后的代码\n\twait属于Object的成员方法，一旦一个对象调用了wait方法，必须要采用notify()和notifyAll()方法唤醒该进程，如果线程拥有某个对象或某些对象的同步锁，那么在调用wait()后，这个线程就会释放它持有的所有同步资源，而不限于这个被调用了wait()方法的对象，wait()方法同样会在wait的过程中有可能被其他对象调用了interrupt方法而产生interruptedException，效果以及处理方式同sleep()\n\n3.join()和yield()的区别\n\t\n\tJoin() 当某个程序执行过程中调用其他线程的join()方法时，调用线程将被阻塞，直到被join()方法加入的join线程执行完为止。\n\tyield() 在运行期间，让出当前线程正在占用的处理器资源。\n\n4.解释序列化、反序列化、持久化\n\n\t序列化：Java序列化是指把Java对象转换为字节序列的过程\n\t反序列化：Java反序列化是指把字节序列恢复为Java对象的过程\n\t持久化：持久化是将内存中的数据存储到硬盘的过程\n\n5.同步锁，互斥锁，死锁\n\n\t同步锁：当synchronized修饰同一段代码时,多个线程不能同时进入这段代码\n\t互斥锁:当synchronized修饰的是两段代码，但是\"锁对象\"相同时，这两段代码就是互斥的。\n\t死锁的四个必要条件：\n\t1：互斥条件：一个资源每次只能被一个进程使用\n\t2：请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。\n\t3：不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺\n\t4：循环等待条件：若干进程之间形成一种头尾相接的循环等待资源\n","tags":["线程"],"categories":["interview"]},{"title":"WEB前端HTML","url":"/2018/08/30/前端HTML/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\nWEB前端\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n###HTML\n\tHyper Text Markup Language：超文本标记语言 \n- 什么是超文本：不仅仅是文本，还包括文本的字体颜色，样式 还包括多媒体（图片，音频，视频）\n- html学习内容： 学习有哪些固定的标签，还有标签内部有哪些属性和标签和标签之间的嵌套关系\n\n###通过Eclipse创建html文件 \n- 新建文件-> other->搜索html \n\n###html结构\n\n\t\t<!DOCTYPE html>   //文档声明 告诉浏览器使用html的哪个版本来解析页面内容 ，此写法是告诉浏览器用最新的html5的版本解析 \n\t\t<html>//所有内容都在html标签内部 除了 文档声明\n\t\t\t<head>//头 ：里面的内容是给浏览器看的 比如使用什么编码 \n\t\t\t</head>\n\t\t\t<body>//体 ：里面的内容是给用户看的 \n\t\t\t</body>\n\t\t</html>\n####head里面的标签\n\n\t\t<meta charset=\"UTF-8\">：告诉浏览器使用哪种字符集解析\n\n\t\t<title>Insert title here</title> 告诉浏览器 页面标题是什么，title还可以起到优化SEO的作用（让搜索引擎尽快搜索到此页面）\n\t\t keywords的作用：让搜索引擎尽快的找到本页面\n\n###Body内部的标签\n####文本标签\n\t\t\n\t\t1. <h1></h1>.......<h6></h6> 内容标题\n\t\t- align：left/center/right  水平对齐方式\n\t\t2. <p></p>    段落标签 ，每个段落标签独占一行并且上下会留有空白区域\n\t\t3. <hr> 水平分割线\n\t\t4. <br> 换行\n####列表标签\n\t\t\n1. 无序列表：\n \n\t\t\t<ul type=\"circle\"> <!-- u:unordered 无序 l:list 列表 -->\n\t\t\t\t<li>刘备</li><!--l:list列表 i:item 项  -->\n\t\t\t\t<li>貂蝉</li>\n\t\t\t\t<li>孙尚香</li>\n\t\t\t\t<li>孙悟空</li>\n\t\t\t</ul>\n\n2. 有序列表\n\t\t\t\n\t\t\t<ol>\n\t\t\t\t<li>打开冰箱门</li> \n\t\t\t\t<li>把大象装进去</li>\n\t\t\t\t<li>关上冰箱门</li>\n\t\t\t\t<li>啦啦啦</li>\n\t\t\t</ol>\n- 常见属性： type 控制每个列表项前面的表示的（a A i I 1默认） start 列表数值的起始值  reversed 倒序\n\t\t\n3. 定义列表\n\n\t\t<h3>定义列表</h3>\n\t\t<dl><!-- defined list 定义一个列表 -->\n\t\t\t<dt>凉菜</dt><!--defined title 定义标题 -->\n\t\t\t<dd>老醋花生</dd><!--defined data 定义数据  -->\n\t\t\t<dd>花毛一体</dd>\n\t\t\t<dd>大拌菜</dd>\n\t\t\t<dt>炒菜</dt>\n\t\t\t<dd>宫保鸡丁</dd>\n\t\t\t<dd>小炒肉</dd>\n\t\t\t<dd>木须肉</dd>\n\t\t</dl>\n \n4. 列表嵌套\n- 有序和无序列表可以任意嵌套多层\n\n###分区标签（元素） div和span \n- 对页面进行分区有两大好处：\n1. 可以多个页面复用同一个区域的内容\n2. 可以对整个区域的内容进行统一管理\n- 分区元素本身没有显示效果，起到容器的作用\n- div： 块级分区 独占一行 \n- span： 行内分区 和多个行内分区元素 共占一行 \n- 通常一个页面会分为三大区域\n\t\t\n\t\t<body>\n\t\t\t<div>头部区域</div>\n\t\t\t<div>正文区域</div>\n\t\t\t<div>尾/脚部区域</div>\n\t\t</body>\n- 在html5中提出了几个分区元素 效果和div一样，但是代码可读性增强了\n\t\t<body>\n\t\t\t<header>头部区域</header>\n\t\t\t<article>正文区域</article>\n\t\t\t<footer>脚部区域</footer>\n\t\t</body>\n####元素的分类\n- 块级元素：独占一行\n\t包括： h1-h6, p,div,hr\n- 行内元素：和多个行内元素共占一行\n\t包括：span, <i></i>和 <em></em>（斜体）<b></b>和<strong></strong>(粗体)  <u></u>下划线   <s></s>和<del></del>删除线\n####行内元素空格折叠现象\n- 行内元素中空格如果有多个只能识别一个空格\n####需要转义的常见特殊字符 实体引用\n- 空格： &nbsp;\n- < : &lt;\n- > : &gt;\n- 换行：<br>\n\n###图片元素\n- <img>属于单标签\n- 常见属性：\n1. alt：当图片不能正常显示的时候显示此文本\n2. src：写图片的路径，路径分为两种：\n- 绝对路径：以http开头的路径，此路径可以指向本网站也可以指向其它网站(盗链，盗链图片如果原网站图片发生改变则不能正常显示)\n- 相对路径：相对于当前页面html文件 1. 图片和页面文件在同一个文件夹下，直接写文件名，2. 图片在页面文件的上一层文件夹 ../文件名  3. 在页面文件的下一层文件夹  文件夹名/文件夹名/文件名\n- 路径总结： 如果是站内资源使用相对路径，站外资源使用绝对路径\n- 图床：专门存放图片的网站，使用图床可以节省本站空间\n3. title:图片标题 当鼠标悬停在图片上面的时候显示\n4. width：设置图片的宽度，两种方式：像素和百分比，如果只设置宽度 高度会保证宽高比的情况下自动跟着宽度改变\n5. height: 设置图片的高度，两种方式：像素和百分比。\n\n- img支持的图片格式： jpg  png  gif\n\n\n\n####Map 图像地图\n- 什么是图像地图： 可以将图片的某个区域作为可点击的链接\n- 使用方式：\n\n\t\t<!-- usemap:使用地图 #代表当前页面 -->\n\t\t<img alt=\"\" src=\"../imgs/b.jpg\" usemap=\"#mymap\">\n\t\t<!-- 为了保证兼容性问题 把name和id都写上  -->\n\t\t<map name=\"mymap\" id=\"mymap\">\n\t\t\t<!-- area区域  shape形状 rect矩形 coords坐标-->\n\t\t\t<area shape=\"rect\" coords=\"0,0,200,200\" \n\t\t\t\t\thref=\"../imgs/2.gif\">\n\t\t\t<area shape=\"circle\" coords=\"663,473,90\"\n\t\t\t\t href=\"../imgs/d.jpg\">\n\t\t</map>\n- map中的id和name作用是让图片能够找得到此地图\n- area常见属性： shape表示形状 常用有circle和rect\n- href：值为一个路径，可以写相对路径和绝对路径，路径可以指向页面，也可以指向文件（浏览器可以打开的文件直接浏览，不能打开的文件则下载）\n\n###超链接 a标签\n- 如果a标签没有添加href属性 就相当于一个文本不是超链接\n- href属性和图像地图中的href作用一样\n- target=\"_blank\" 开启一个新的页面\n- 锚点用法： 需要先创建锚点:<a id=\"a\" name=\"a\"></a>, 然后通过a标签跳转到锚点的位置：<a href=\"#a\">跳转到锚点</a>\n- img标签放在a标签内部 则图片就可以被点击了\n###练习：1号美女  2号美女   3号美女    4号帅哥\n\n###表格 table\n- 接触标签有 table tr td\n- table的属性：align水平对齐 width宽度 border边框 cellspacing边框和单元格的距离 cellpadding内容和单元格的距离 \n- td的属性：colspan跨列  rowspan跨行 align水平对齐\n- caption标签\n- 分组标签：<thead> <tbody> <tfoot>  没有任何显示效果，提高代码可读性\n\n###表单\n- 表单的作用是收集用户的数据提交到服务端\n- 表单中的控件包括： 文本框、密码框、按钮、下拉列表、单选、复选、时间选择、文件选择、文本域\n####文本框 \n\n\t\t<input type=\"text\" placeholder=\"占位文本\" maxlength=\"最大字符长度\" readonly=\"只读\" >\n####密码框\n\n\t\t<input type=\"password\" maxlength>\n\n####单选\n\n\t\t<input type=\"radio\" checked默认选中>\n\n####多选、复选框\n\n\t\t<input type=\"checkbox\" id=\"aaa\">  <label for=\"aaa\">xxx</label>\n\n####时间\n\n\t\t<input type=\"date\" >\n\n####文件\n\n\t\t<input type=\"file\" >\n\n####下拉选\n\n\t\t<select name>\n\t\t\t\t<option value selected></option>\n\t\t<select>\n\n####文本域 \n\t\n\t\t<textarea rows=\"行数\" cols=\"列数\"></textarea>\n\n####隐藏域\n\n\t\t<input type=\"hidden\">\n\n####按钮\n\n\t\t<input type=\"submit/reset/button\" value=\"按钮标题\">\n####代码\n1. 图像地图Map  \n\t\t\t\n\t\t<img usemap=\"#mymap\">\n\t\t<map name=\"mymap\" id=\"mymap\">\n\t\t<area shape=\"rect/circle\" coords=\"\" href=\"\"></area>\n\t\t</map>\n\n2. 超链接 a\n\t\t\n\t\t<a href=\"\" target=\"_blank\">超链接</a>\n\t\t<a id name ></a>   <a href=\"#id/name\">跳转</a>\n3. 表格 \n\t\n\t\t<table border cellspacing cellpadding width align>\n\t\t<tr>行\n\t\t<td rowspan  colspan align>列\n\t\t<th>表头\n\t\t<thead> <tbody> <tfoot>  \n\t\t<caption> 表的标题\n\n4. 表单  文本框 密码框 单选 多选  文件 日期  隐藏域 按钮 下拉选 文本域\n\n\t\t<input type=\"text/password/radio/checkbox/file/date/hidden/submit/reset/button\" name value id checked placeholder readonly maxlength>\n\t\t<label for=\"id\">\n\t\t<select name><option value selected>\n\t\t<textarea rows   cols >","tags":["HTML"],"categories":["front-end"]},{"title":"Java面向对象-雷霆战机","url":"/2018/07/23/Java面向对象雷霆战机/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n<!-- more -->\n<The rest of contents | 余下全文>\n\n雷霆战机搭建过程","tags":["雷霆战机\\小游戏"],"categories":["after-end"]},{"title":"环境搭建(附链接)","url":"/2018/06/23/环境搭建连接详细版/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n<!-- more -->\n<The rest of contents | 余下全文>\n第一步：搭建环境。\n\n\t安装新建虚拟机CentOS。环境搭建好之后。\n\n第二步：安装jdk（我使用的第一种方法）\n\n*[linux系统下安装jdk](https://blog.csdn.net/qciwyy/article/details/77449369)\n\n\n第三步：安装mysql服务器（我使用的方法2）\n\n*[linux系统安装mysql-server](https://blog.csdn.net/qciwyy/article/details/77526895)\n\n第四步：修改mysql-server登陆密码\n\n*[修改mysql root密码](https://blog.csdn.net/qciwyy/article/details/77529153)\n\n第五步：mysql创建用户并授予远程访问权限\n\n*[linux系统给mysql创建新用户并授予远程访问权限](https://blog.csdn.net/qciwyy/article/details/77643595)\n\n第六步：mysql表明区分大小写转换为不区分大小写（这样为了避免在设计表的时候有大写和小写出现异常）\n\n*[linux下mysql表名不区分大小写](https://blog.csdn.net/qciwyy/article/details/77648715)\n\n第七步：MySQL数据库从Windows迁移到linux\n\n*[MySQL数据库从Windows迁移到linux](https://blog.csdn.net/QCIWYY/article/details/77567154)\n\n第八步：CentOS中安装与配置Tomcat\n\n*[linux系统安装tomcat](https://blog.csdn.net/qciwyy/article/details/77645638)\n\n第九步：Tomcat安装成功后， 将需要部署的java web项目复制到/usr/local/tomcat/webapps下，重新起到tomcat服务\n\n\t浏览器输入：localhost:8080/HelloWorld  成功访问。\n\n\n","tags":["JDK Tomcat MySql"],"categories":["servicer"]},{"title":"Html部分","url":"/2018/06/23/面试题Html/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n<!-- more -->\n<The rest of contents | 余下全文>\n一、\t索引有几种类型？\n\n\ta)\t4种类型：\n\t\t1.\t唯一索引：\t\t不允许其中任何两行具有相同索引值得索引。\n\t\t2.\t非唯一索引：\n\t\t1.\t主键索引：\t\t数据库表经常有一列或者多列组合，其值唯一标识表中的每一行。该列称为表的主键。在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。\n\t\t3.\t聚集索引：\t\t在聚集索中，表中行的物理顺序与键值得逻辑（索引）顺序相同。一个表只能包含一个聚集索引\n二、\tCSS选择器包括哪些？\n\t\n\ta)\t类选择器：\t\t用“.”来标识\n\tb)\t标签选择器：\t用“HTML”标签来标识\n\tc)\tID选择器：\t\t用“#”号来标识\n三、\tJavaScript包括哪些数据类型？\n\t\n\ta)\t6种数据类型\n\t1.\tUndefined   原始数据类型\n\t2.\tNull\t\t原始数据类型\n\t3.\tString\t\t原始数据类型\n\t4.\tNumber\t\t原始数据类型\n\t5.\tBoolean\t\t原始数据类型\n\t6.\tObject\t\t对象数据类型\n四、\tServlet生命周期？\n\t\n\ta)\t（Web容器）服务器启动并加载Servlet后，Servlet生命周期开始，容器运行init方法，请求到达时运行其service方法，\n\t请求到达，service方法自动派遣运行与请求对应的doGet或doPost方法，当服务器决定将实例销毁的时候调用其destroy方法。\n五、\t什么是Servlet？\n\n\ta)\tServlet就是处理服务器与客户端交互的一个组件，主要用于响应HTTP请求，一般在MVC中的C(controller)控制层\n六、\tB/S和C/S的区别？\n\t\n\ta)\tB/S是浏览器与服务器\t\t不安全\t\t维护成本低\t 一般用于广域网  \n\tb)\tC/S是客户端与服务器\t\t安全\t\t维护成本高   一般用于局域网\n七、\tMVC各个部分都有哪些技术来实现？\n\t\n\ta)\tM是model简写 也就是业务逻辑层（通过javaBean，EJB组件实现）\n\tb)\tV是View简写，也就是应用的表面层（由jsp页面产生）\n\tc)\tC是controller简写，也就是提供应用的处理过程控制（一般是一个Servlet），\n\td)\t通过这种设计模式把应用逻辑，处理过程，和显示逻辑分成不同的组件，这些组件可以交互和重用。\n八、\tServlet如何获取表单的参数？\n\t\n\ta)\t通过request.getParamenter();\n\t九、\tJSP和Servlet的异同？他们之间的联系是什么？\n\ta)\tJSP本质上就是Servlet技术的拓展，也就是简易版的servlet。\n\tb)\tJSP更加强调应用的外表表达，侧重于视图，Servlet更加注重于控制逻辑。\n\tc)\tJSP编译后是类Servlet\n\td)\tJSP是Java和HTML组合成的一个扩展名为.jsp的文件\n十、\tServlet中的转发（Forword）和重定向(Redirect)有什么区别？\n\n\ta)\t转发是一个请求的延续（1个请求），可以共享request的数据\n\tb)\t重定向是开始一个新的请求，（2个请求），不可以共享request数据\n\tc)\t地址栏：转发地址栏不发生变化，重定向地址栏是会变化的\n十一、\tCookie和Session的区别？\n\t\n\ta)\t存储位置：Cookie存在浏览器，Session存储在服务器\n\tb)\t安全角度：cookie不安全，session安全\n\tc)\t数据量：  cookie不可以存大数据，session可以存大数据，重要数据等.\n十二、\tHttp中get和post的 区别\n\t\n\ta)\t在客户端：Get方式在通过URL提交数据，数据在URL可以看到,POST方式，数据放置在HTML HEADER内提交\n\tb)\tGet方法提交的数据最多只有1024字节，post则没有限制\n\tc)\tGet不安全，Post安全\n十三、\tJSP有哪些内置对象？\n\n\ta)\tRequest  response out\t\t\t\t: 输入输出对象\n\tb)\tSession application pageContext\t\t：作用域通信对象\n\tc)\tPage config\t\t\t\t\t\t\t：Servlet对象\n\td)\tException\t\t\t\t\t\t\t：异常对象\n十四、\tJSP乱码如何解决？\n\t\n\ta)\t3种方法\n\t\t1.\tJSP页面乱码：<%@page contentType=”text/html;charset=utf-8”%>\n\t\t2.\t表单提交中文时候出现的乱码：request.setCharacterEncoding(“utf-8”);\n\t\t3.\t数据库连接出现乱码：\tuseUnicode=true&characterEncoding=utf-8;\n\n\n\n\n","tags":["面试资料"],"categories":["interview"]},{"title":"Spring框架部分","url":"/2018/06/23/面试题Spring框架/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n<!-- more -->\n<The rest of contents | 余下全文>\n\n一、\t你用过spring框架吗？\n\n\ta)\t用过，spring框架是轻量级，代码侵入性低,可集成，用来简化web开发的应用开发的框架。 \n二、\tSpring容器是什么？\n\n\ta)\t是Spring框架当中的一个核心模块，用于对对象进行管理。\n三、\t什么是IOC什么是DI？DI如何实现的？\n\n\ta)\tIOC叫控制反转，是Inversion of Control 的缩写。\n\t所谓的“控制反转”就是对组件对象控制权的转移，从程序代码本身转移到了外部容器，由容器来创建对象并管理对象之间的依赖关系。\n\tb)\tDI 叫依赖注入，是Dependency Control的缩写，是对IOC更简单的诠释。\n四、\tSpring中的Bean的作用域有哪些？\n\n\ta)\t两个作用域\n\t\t1.\tSingleton: 表示Bean以单例的形式存在。一般情况下，无状态或状态不可变的类适合单例模式。\n\t\t2.\tPrototype:\t表示每次从容器中调用Bean时，都会返回一个新的实例。\n五、\t请你阐述下SpringMVC分为几大组件？SpringMVC的执行流程（也就是这五大组件的关系）\n\n\ta)\t五大组件：\n\t\t1.\tdispatcherServlet\t (前端控制器)\n\t\t2.\thandlerMapping\t\t（前端控制器秘书）\n\t\t3.\tcontroller\t\t\t（处理器）\n\t\t4.\tViewResolver\t\t（视图解析器）\n\t\t5.\tModelAndView\t\t（模型和视图）\n\tb)\tdispatcherServlet前段控制器收到请求之后，依据HandlerMapping的配置调用相应的Controller来处理\n\tcontroller将处理结果封装成ModeAndView发送给前段控制器DispatcherServlet\n\tdispatcherServlet前端控制器会依据ViewResolver的配置调用相应的配置，调用相应的视图对象（比如JSP）\n\t来展现数据\n六、\t你了解Java反射机制吗？Java中哪些地方用到了反射？\n\n\ta)\t就是在运动状态中，对于任意一个类，都能够知道这个类的所有属性和方法，对于任意一个对象，\n\t都能够调用它的任意一个方法和属性；这种动态获取信息以及动态调用对象的方法的功能称为反射。\n\tb)\tSpring框架底层就是通过反射实现的。\n七、\t什么是MyBatis框架？\n\n\ta)\t作用就是封装了JDBC,简化了数据库的访问代码。\n八、\tMyBatis中的Mapper映射器要满足那些要求？\n\n\ta)\tMapper.xml的\n\t\t1.\tNamespace\t\t== \t接口名\n\t\t2.\tsql语句id\t\t==\t方法名\n\t\t3.\tparameterType\t==  方法参数类型\n\t\t4.\tresultType\t\t==\t返回值类型\n九、\t解释一下什么叫AOP Aspect Oriented Programming（面向切面编程）？\n\t\n\ta)\tAOP可以对业务逻辑的各个部分进行隔离，也就是可以降低业务逻辑各部分的耦合度，提高程序的可重用性，提高开发效率。\n\tb)\t主要的功能有5点（或更多）：\n\t\t1.\t日志记录\n\t\t2.\t性能统计\n\t\t3.\t安全控制\n\t\t4.\t事务处理\n\t\t5.\t异常处理\n十、\tAOP和OOP有什么区别？\n\n\ta)\tAOP、OOP在字面上虽然非常类似，但却是面向不同领域的两种设计思想。\n\tb)\tOOP（面向对象编程）针对业务处理过程的实体及其属性和行为进行抽象封装，以获得更加清晰高效的逻辑单元划分。\n\tc)\t而AOP则是针对业务处理过程中的切面进行提取，它所面对的是处理过程中的某个步骤或阶段，以获得逻辑过程中各部分之间低耦合性的隔离效果。\n\td)\t总之，AOP可以通过预编译方式和运行期动态代理实现在不修改源代码的情况下给程序动态统一添加功能的一种技术。\n十一、\t什么是AJAX?\n\n\ta)\tajax是一种用来改善用户体验的技术，也就是局部刷新，其本质是利用浏览器内部的一个对象(XMLHttpRequest)异步的向服务器发送请求。\n十二、\tajax对象的几个重要的属性？\n\t\n\ta)\t5个\n\t\t1.\tOnreadystatechange:\t\t用来绑定事件处理函数的\n\t\t2.\tReadystate：\t\t\t有5个值（0,1,2,3,4）表示对ajax对象与服务通信的状态（进展）\n\t\t3.\tresponseText：\t\t\t获得服务器返回的文本\n\t\t4.\tresponseXML：\t\t\t获得服务器返回的xml文档\n\t\t5.\tstatus：\t\t\t\t获得服务器返回的状态码（200/202/400/404/500）\n十三、\tAJAX都有哪些优点和缺点\n\n\t优点:\n\t1.\t最大的一点是页面无刷新，用户的体验非常好。\n\t2.\t使用异步方式与服务器通信，具有更加迅速的响应能力。\n\t3.\t可以把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理，减轻服务器和带宽的负担，节约空间和宽带租用成本。并且减轻服务器的负担，ajax的原则是“按需取数据”，可以最大程度的减少冗余请求，和响应对服务器造成的负担。\n\t4.\t基于标准化的并被广泛支持的技术，不需要下载插件或者小程序。\n\tajax的缺点:\n\t6.\tajax不支持浏览器back按钮。\n\t7.\t安全问题 AJAX暴露了与服务器交互的细节。\n\t8.\t对搜索引擎的支持比较弱。\n\t9.\t破坏了程序的异常机制。\n\t10.\t不容易调试\n十四、\tJSON是什么？语法是怎么样的？\n\t\n\ta)\t是一种轻量级的数据交换模式，比xml要小，解析速度更加快。\n\tb)\t使用JSON表示一个对象{“属性名”：属性值，“属性名”：属性值};\n十五、\t面向对象和面向过程有什么区别？\n\n\ta)\t面向过程是一种以过程为中心的编程思想。就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步的实现，使用的时候一个一个依次调用就可以了。注重的是过程。\n\tb)\t面向对象是一种以事务为中心的编程思想。面向对象的方法主要是把事务给对象化，对象包括属性和行为，忽略某些细节，注重的是结果。\n\tc)\t比如我想去厦门，面向过程是我开什么车去，怎么开，之间的过程是什么，都要很详细。面向对象是我要去厦门，到厦门即可，不管你是怎么到的。\n十六、\tOracle和Mysql有什么区别？\n\n\ta)\t库函数不同\n\tb)\tOracle是用表空间来管理的，Mysql不是\n\tc)\t分页查询的时候mysql是用limt   oracle用rownum\n\td)\tSql的语法不同\n\n\n\n\n\n","tags":["面试资料"],"categories":["interview"]},{"title":"OOP","url":"/2018/06/23/面试题OOP/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n<!-- more -->\n<The rest of contents | 余下全文>\n\n**OOP**\n\n\t1.重写与重载的区别\n\t\t重载：同一个类中，方法名相同，参数列表不同，编译器在编译时会自动根据签名来绑定调用不同的方法。\n\t\t重写：父子类中，方法名和参数列表相同，方法体不同，重写方法被调用时，看对象的类型。\n\t\t重载是发生在同一个类中，方法名相同，参数列表不同，遵循编译器绑定，根据引用的类型绑定方法；重写是发生在父子类中，方法名相同，参数列表相同，遵循运行期绑定，根据对象类型绑定方法。\n\n2.面向对象的三大特征\n\n\t封装：1.类：封装的是对象的数据和行为；\n\t      2.方法：封装的功能是具体的实现；\n\t      3.访问控制修饰符：封装的是数据和行为的访问权限。\n\t继承：1.目的：避免代码的重复，实现代码的重用；\n\t      2.父类中：所有子类共有的，子类中：子类所特有的；\n\t      3.子类继承父类后：具有自己所特有的和父类的数据和行为。\n\t封装和继承都提高了代码的复用性\n\t多态：1.意义：行为的多态：同一类型的引用指向不同的对象时，有不同的实现；对象的多态：同一对象被造型为不同的类型时，有不同的功能。\n\t      2. 向上造型：父类型的引用指向子类的对象，能点出来什么，看引用的类型。子类继承父类, 但是没有实现其中的方法, 当进行向上造型时, 调用的方法就是父类的。\n\t      3.变现形式：重载，重写。\n\n3.Java编译运行过程\n\n\tJava源程序(.java文件)→通过java命令编译源文件→Java字节码文件(.class文件)→通过java命令启动JVM→加载并运行.class文件\n\n4.抽象类Abstract与接口interfae的区别\n\n\t抽象类可以有构造方法，接口不能有构造方法\n\t抽象类可以有普通成员变量和普通方法，接口只能有常量和抽象方法\n\t抽象类可以有静态方法，接口不能有静态方法\n\t抽象类的访问控制修饰符可以是public protected和默认，接口只能是public\n\t一个类可以实现多个接口，但只能继承一个类，接口间可以多继承\n\n5.JavaBean规范\n\n\t1要有包(类必须写在包里)  \n\t2有默认构造器\n\t3有get/set方法  \n\t4实现序列化接口\n\n6.final，finally，finalize的区别\n\t\n\tfinal用于声明属性，方法和类，分别表示属性不可变，方法不能被重写，类不能被继承\n\tfinally是异常处理机制中处理语句结构中的一部分，表示总是执行，通常用于关闭流或连接，释放资源等操作\n\tfinalize是object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件。\n\n7.静态代码块，构造代码块，构造函数执行的顺序\n\n\t如果一个类有父类：父类的静态代码块 子类静态代码块 父类代码块  父类构造方法  子类代码块 子类构造方法 \n\t如果没有父类：静态代码块  代码块  构造方法\n\t注：静态资源只会被加载一次\n\n8.编写一个单例模式、和排序算法\n\t\n\tpublic class A{\n\t\tprivate static A a = new A();\n\t\tprivate A(){}\n\t\tpublic static A getA(){return a;}}\n\t\n\tpublic class B{\n\t\tprivate static B b;\n\t\tprivate B(){}\n\t\tpublic syh... static B getB(){\n\t\tif(b==null){b=new B();}return b;}}\n\t\n\tfor(int i=0;i<ary.length-1;i++){\n\t\tfor(int j=0;j<ary.length-1-i;j++){\n\t\tif(ary[j]>ary[j+1]){.......}}}\n\n9.简单的递归 \n\n\t9-1：兔子生兔子（斐波拉契数列）：1、1、2、3、5、8、13、21\n\t\tpublic int tuzi(int n ){\n\t\t\t\tif(n==1||n==2){return 1;}\n\t\telse{return tuzi(n-1)+tuzi(n-2)}} \n\t9-2：猴子吃桃：1、4、10、22、46\n\t\tpublic int houzi(int n){\n\t\tif(n==1){return 1;}else{\n\t\treturn 2*houzi(n-1)+2;}}}\n10. 下列代码输出结果（10  0  20  99）\n\n\t\tclass ValHold {public int i = 10;}\n\t\tpublic class ObParm {\n\t\tpublic static void main(String[] args) {\n\t\t\tObParm o = new ObParm();\n\t\t\to.amethod();}\n\t\tpublic void amethod() {\n\t\t\tint i = 99;\t\tValHold v = new ValHold();\n\t\t\tv.i = 30;\t\tanother(v, i);\n\t\t\tSystem.out.println(v.i + \" \" + i);}\n\t\tpublic void another(ValHold v, int i) {\n\t\t    \ti = 0;\tv.i = 20;\t\n\t\t\tValHold vh = new ValHold();\t\tv = vh;\t\t\n\t\t\tSystem.out.println(v.i + \" \" + i);}}\n\n","tags":["OOP"],"categories":["interview"]},{"title":"环境搭建Centos7.4","url":"/2018/06/23/环境搭建centos7.4/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n<!-- more -->\n<The rest of contents | 余下全文>\n>##安装jdk\n\n1. 下载jdk\n\n\t\twget http://download.oracle.com/otn-pub/java/jdk/8u181-b13/96a7b8442fe848ef90c96a2fad6ed6d1/jdk-8u181-linux-x64.rpm?AuthParam=1536633909_fcc6805cd13d0e7e32ce7e7b69ce0620\n2.将文件放至/usr/local\n\t\n\t\t scp /Users/leelom/Downloads/jdk-7u79-linux-x64.rpm root@123.xxx.xx.xx:/usr/local\n\n2. 安装jdk\n\n\t\trpm -ivh jdk-8u181-linux-x64.rpm\n3. 查询java版本号\n  \n\t     此处出现版本号 jdk1.8.0_181 \n4.修改配置\n\t\n\t\t vi /etc/profile\n5. 复制以下内容\n\n文件名不同 复制内容不同\n\n\t\tJAVA_HOME=/usr/java/jdk1.8.0_181-amd64\n\t\tJRE_HOME=/usr/java/jdk1.8.0_181-amd64/jre\n\t\tPATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin\n\t\tCLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib\n\t\texport JAVA_HOME JRE_HOME PATH CLASSPATH\n\n\t###添加以下文档 \n\n\t\tJAVA_HOME=/usr/java/jdk1.8.0_181 \n\t\tJRE_HOME=/usr/java/jdk1.8.0_181/jre \n\t\tPATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin \n\t\tCLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib \n\t\texport JAVA_HOME JRE_HOME PATH CLASSPATH\n\n>##安装Tomcat\n此处为tomcat9版本\n\n1.下载tomcat\n\t\n\t wget http://mirrors.sonic.net/apache/tomcat/tomcat-9/v9.0.11/bin/apache-tomcat-9.0.11.tar.gz\n2. 解压压缩包\n\t\t\n\ttar -zxf apache-tomcat-9.0.11.tar.gz \n3.删除压缩包\n\n\t rm -rf apache-tomcat-9.0.11.tar.gz  \n4.文件移动\n\n\t mv  apache-tomcat-9.0.11 tomcat \n5. 启动tomcat\n\t\n\t\t [root@admin ~]# /usr/local/tomcat/bin/startup.sh //启动tomcat  \n\t\tUsing CATALINA_BASE: /usr/local/tomcat  \n\t\tUsing CATALINA_HOME: /usr/local/tomcat  \n\t\tUsing CATALINA_TMPDIR: /usr/local/tomcat/temp  \n\t\tUsing JRE_HOME: /usr/java/jdk1.7.0/jre  \n\t\tUsing CLASSPATH: /usr/local/tomcat/bin/bootstrap.jar:/usr/local/tomcat/bin/tomcat-juli.jar \n6. 浏览器  http://ip:8080  验证\n7. 修改配置 tomcat server.xml\n\t* [server.xml](http://blog.csdn.net/jimmy609/article/details/37766069)\n\n\n>##安装MySQL\n\n* [CentOS 7.4下使用yum安装MySQL5.7.20 最简单的](https://blog.csdn.net/z13615480737/article/details/78906598)","tags":["Centos7.4   Jdk8  Tomcat9  Mysql5.7.20"],"categories":["servicer"]},{"title":"Java基础","url":"/2018/06/23/Java基础Basic/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n<!-- more -->\n<The rest of contents | 余下全文>\n\n> **Java开发环境:**\n\n*1)java编译运行过程:-------------常见面试题*\n\n\t    1.1)编译期:.java源文件，经过编译，生成.class字节码文件\n\t    1.2)运行期:JVM加载.class并运行.class\n    \t\t特点:跨平台、一次编程到处使用\n  *2)名词解释:-------------常见面试题*\n\n    2.1)JVM:java虚拟机\n            加载.class并运行.class\n    2.2)JRE:java运行环境\n            除了包含JVM以外还包含了运行java程序所必须的环境\n\t    JRE=JVM+java系统类库(小零件)\n    2.3)JDK:java开发工具包\n            除了包含JRE以外还包含了开发java程序所必须的命令工具\n\t    JDK=JRE+编译、运行等命令工具\n    说明:\n      2.1)运行java程序的最小环境为JRE\n      2.2)开发java程序的最小环境为JDK\n  *3)配置环境变量---------------了解*\n\n    3.1)JAVA_HOME:指向jdk的安装路径\n    3.2)CLASSPATH:表示类的搜索路径(一般简写为.)\n    3.3)PATH:指向jdk下的bin目录\n\n> **eclipse:**\n\n\t  1)IBM、开源的、免费的、不需要安装仅需解压即可\n\t  2)开发步骤:\n\t    2.1)新建Java项目/工程---------------小区\n\t    2.2)新建Java包----------------------楼+单元\n\t    2.3)新建Java类----------------------房子\n\t          main中:\n\t\t    System.out.println(\"HelloWorld\");\n\t  3)注释:解释性文字\n\t    3.1)单行注释://\n\t    3.2)多行注释:/* */\n\t    3.3)文档注释:/** */\n\n>**变量:存数的，代词，指代的就是它所存的那个数**\n\t\n\t  1)声明:\n\t      int a; //声明一个整型的变量，名为a\n\t      int b,c,d; //声明三个整型的变量，名为b,c,d\n\t  2)初始化:第一次赋值\n\t    2.1)声明的同时初始化:\n\t          int a = 250; //声明整型变量a并赋值为250\n\t    2.2)先声明后初始化:\n\t          int a;   //声明整型变量a\n\t\t \t  a = 250; //给变量a赋值为250\n\t  3)使用:\n\t    3.1)对变量的使用就是对它所存的那个数的使用\n\t          int a = 5;\n\t\t\t  int b = a+10; //取出a的值5，加10后，再赋值给整型变量b\n\t\t\t  System.out.println(b);   //输出变量b的值15\n\t\t\t  System.out.println(\"b\"); //输出b，双引号中的原样输出\n\t\t\t  a = a+10; //取出a的值5，加10后，再赋值给a\n\t\t\t            //在a本身基础之上增10\n\t\t\t  System.out.println(a); //15\n\t    3.2)变量在使用时必须类型匹配\n\t          int a = 3.14; //编译错误，数据类型不匹配\n\t    3.3)变量在用之前必须声明并初始化\n\t          System.out.println(m); //编译错误，m未声明\n\t\t \t  int m;\n\t\t \t  System.out.println(m); //编译错误，m未初始化\n\t  4)命名:\n\t    4.1)只能包含字母、数字、_和$符，并且不能以数字开头\n\t    4.2)严格区分大小写\n\t    4.3)不能使用关键字\n\t    4.4)可以中文命名，但不建议\n\t        建议\"英文的见名知意\"、\"驼峰命名法\"\n>**基本数据类型:共8种**\n\n\t  1)int:整型，4个字节，-21个多亿到21个多亿\n\t\t    1.1)整数直接量默认为int型，但不能超范围，超范围则编译错误\n\t\t    1.2)两个整数相除，结果还是整数，小数位无条件舍弃(不会四舍五入)\n\t\t    1.3)运算时超范围，则发生溢出，溢出是需要避免的\n\t  2)long:长整型，8个字节，很大很大很大\n\t\t    2.1)表示长整型直接量，需在数字后加L或l\n\t\t    2.2)运算时若有可能溢出，建议在第1个数字后加L\n\t\t    2.3)System.currentTimeMillis()用于获取自\n\t\t        1970.1.1零时到此时此刻的毫秒数\n\t  3)double:浮点型，8个字节，\n\t\t    3.1)浮点数直接量默认为double型，若想表示float需在数字后加f或F\n\t\t    3.2)double和float在运算时，有可能会出现舍入误差(精确运算场合不能使用)\n\t  4)boolean:布尔型，1个字节\n\t  \t    4.1)只能取值为true和false\n\t  5)char:字符型，2个字节\n\t\t    5.1)采用Unicode字符集编码，一个字符对应一个码(0到65535之间)\n\t\t        表现的形式的字符char，但本质上是码int\n\t\t\tASCII码('a'--97  'A'--65  '0'--48)\n\t\t    5.2)字符直接量必须放在单引号中，只能有一个\n\t\t    5.3)特殊符号需通过\\来转义\n>**基本数据类型间的转换:**\n\n    数据类型从小到大依次为:\n      byte,short,int,long,float,double,char,\n\n\t  1)两种方式:\n\t    1.1)自动类型转换:小类型到大类型\n\t    1.2)强制类型转换:大类型到小类型\n\t          eg: (要转换成为的数据类型)变量\n\t\t  强转有可能溢出或丢失精度\n\t  2)两点规则:\n\t    2.1)整数直接量可以直接赋值给byte,short,char，但不能超出范围\n\t    2.2)byte,short,char型数据参与运算时，先一律转换为int再运算\n>**Scanner接收用户的输入:**\n\n\t  1)在package下:\n\t      import java.util.Scanner;\n\t  2)在main()中:\n\t      Scanner scan = new Scanner(System.in);\n\t  3)在第2步之下:\n\t      System.out.println(\"请输入年龄:\");\n\t      int age = scan.nextInt();\n\t      System.out.println(\"请输入价格:\");\n\t      double price = scan.nextDouble();\n>**运算符:**\n\t\n\t  1)算术运算符:+,-,*,/,%,++,--\n\t  2)关系运算符:>,<,>=,<=,==,!= boolean\n\t  3)逻辑运算符:&&,||,! boolean\n\t  4)赋值运算符:=,+=,-=,*=,/=,%=\n\t  5)字符串连接运算符:+\n\t  6)条件/三目运算符:boolean?数1:数2\n>**分支结构:**\n\n\t  1)if结构:1条路\n\t  2)if...else结构:2条路\n\t  3)if...else if结构:多条路\n\t  4)switch...case结构:多条路\n\t    优点:效率高、结构清晰\n\t    缺点:整数、相等\n\t    break:跳出switch\n>**循环:**\n\n\t反复执行一段相同或相似的代码\n\n>**循环三要素:**\n\n\t  1)循环变量的初始化\n\t  2)循环的条件(以循环变量为基础)\n\t  3)循环变量的改变(向着循环的结束变)\n\t  循环变量:在整个循环过程中所反复改变的那个数\n>**循环结构:**\n\n\t  1)while结构:先判断后执行，有可能一次都不执行\n\t  2)do...while结构:先执行后判断，至少执行一次\n\t                   要素1与要素3相同时，首选do...while\n\t  3)for结构:应用率最高，固定次数循环\n\n>**break:跳出循环**\n\n \t continue:跳过循环体中剩余语句而进入下一次循环\n>**三种循环结构的更佳适用情况:**\n\n\t  1)while:\"当...\"\n\t          要素1与要素3不同时首选while\n\t  2)do...while:\"直到...\"\n\t          要素1与要素3相同时首选do...while\n\t  3)for:固定次数循环，应用率最高\n>**嵌套循环:**\n\n\t  1)循环中套循环，一般多行多列时使用，外层控制行，内层控制列\n\t  2)执行规则:外层循环走一次，内层循环走所有次\n\t  3)建议:嵌套层数越少越好，能用一层就不用两层，能用两层就不用三层\n\t    若需求必须要使用三层以上的循环才能解决，说明设计有问题\n\t  4)break只能跳出一层循环\n>**程序=算法+数据结构------------了解**\n\n\t  1)算法:解决问题的流程/步骤(顺序、分支、循环)\n\t  2)数据结构:将数据按照某种特定的结构来保存\n\t             数怎么存\n\t    设计良好的/合理的数据结构会导致好的算法\n>**数组:**\n\t\n\t  1)是一种数据类型(引用类型)\n\t  2)相同数据类型元素的集合\n\t  3)数组的定义:\n\t      int[] arr = new int[10];\n\t  4)数组的初始化:\n\t\t      int[] arr = new int[3]; //0,0,0\n\t\t      int[] arr = {2,5,8}; //2,5,8\n\t\t      int[] arr = new int[]{2,5,8}; //2,5,8\n\t\t      int[] arr;\n\t\t      arr = {2,5,8}; //编译错误，此方式只能声明同时初始化\n\t      \t  arr = new int[]{2,5,8}; //正确\n\t  5)数组的访问:\n\t    5.1)通过数组名.length可以获取数组的长度(元素的个数)\n\t          int[] arr = new int[10];\n\t\t  \t  System.out.println(arr.length); //10\n\t    5.2)通过数组的下标/索引来访问元素\n\t        下标从0开始，最大到(数组的长度-1)\n\t\t\t  int[] arr = new int[3];\n\t\t\t  arr[0] = 100; //给arr中第1个元素赋值为100\n\t\t\t  arr[1] = 200; //给arr中第2个元素赋值为200\n\t\t\t  arr[2] = 300; //给arr中第3个元素赋值为300\n\t\t\t  arr[3] = 400; //数组下标越界异常\n\t\t\t  System.out.println(arr[arr.length-1]); //输出最后一个元素的值\n\t  6)数组的遍历:\n\t\t      int[] arr = new int[10];\n\t\t      for(int i=0;i<arr.length;i++){\n\t\t        arr[i] = 100;\n\t\t      }\n\t\t      for(int i=0;i<arr.length;i++){\n\t\t        System.out.println(arr[i]);\n\t\t      }\n\t\t      for(int i=arr.length-1;i>=0;i--){\n\t\t        System.out.println(arr[i]);\n\t\t      }\n\t  7)数组的复制:\n\t\t    7.1)System.arraycopy(a,1,a1,0,4); //效率高、灵活性好\n\t\t    7.2)int[] a1 = Arrays.copyOf(a,6); //效率低、灵活性差\n\t\t        a = Arrays.copyOf(a,a.length+1); //数组的扩容/缩容\n\t  8)数组的排序:\n\t\t    8.1)Arrays.sort(arr); //升序，效率高\n\t\t    8.2)冒泡排序:----车轮战\n\t\t        8.2.1)四个数冒三轮\n\t\t\t8.2.2)每一轮都是从第1个元素开始冒\n\t\t\t      每一次都是和它的下一个元素比\n\t\t\t8.2.3)冒出来的就不再参与比较了\n>**方法:**\n\t\n\t  1)封装一段特定的业务逻辑功能\n\t  2)尽可能独立，一个方法只干一件事\n\t  3)可以被反复多次调用\n\t  4)减少代码的重复，有利于代码的维护，有利于团队的协作\n>**方法的定义:**\n\n\t    修饰词 返回值类型 方法名(参数列表){ //形参\n\t      方法体\n\t    }\n>**方法的调用:**\n\n\t  1)无返回值: 方法名(有参传参); //实参\n\t  2)有返回值: 数据类型 变量 = 方法名(有参传参);\n>**return:**\n\n\t  1)return 值; //1.1)结束方法的执行 1.2)返回结果给调用方\n\t  2)return;    //2.1)结束方法的执行(在某种条件之下提前结束方法)\n","tags":["基础"],"categories":["after-end"]},{"title":"Java面向对象","url":"/2018/06/23/Java面向对象/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n<!-- more -->\n<The rest of contents | 余下全文>\n\n面向对象","tags":["OOP"],"categories":["after-end"]},{"title":"Java面试资料","url":"/2018/06/23/面试题Java基础/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n<!-- more -->\n<The rest of contents | 余下全文>\n\n>*一、\t继承的好处和弊端是什么？*\n\n\t（什么是继承：继承是一种连接的层次模型，鼓励类的重用）\n\ta)\t好处是：提高代码复用性，维护性，让类与类之间产生了关系，是多态的前提。\n\tb)\t弊端是：类的耦合性增强了，java开发的宗旨是高复用，低耦合。\n二、\tJava中继承的特点是什么？\n\n\ta)\tJava只支持单继承，不支持多继承。\n\tb)\t子类不能继承父类私有的属性和方法\n\tc)\t子类不能继承父类的构造方法，但是可以通过super关键字去访问父类的构造方法。\n\td)\t注意不要为了部分功能去继承。\n三、\t重写和重载的区别是什么？\n\n\ta)\t重载：是发生在同一个类中，在该类中如果存在多个同名方法，但是方法的参数列表不同，那么就说明该方法被重载了。（方法名相同，参数列表不同）。\n\tb)\t重写：是发生在子类继承父类的关系中，父类的方法被子类继承，方法名，返回值类型，参数完全是一样的，但是方法体不一样，那么就说明父类的该方法被子类重写了（方法名，参数列表相同，方法体不同）\n四、\tJava 中的final关键字有哪些用法？ \n\n\ta)\t修饰类：表示该类不能被继承；\n\tb)\t修饰方法：表示方法不能被重写；\n\tc)\t修饰变量：表示变量只能一次赋值以后值不能被修改（常量）。\n五、\t阐述final、finally、finalize的区别。\n\n\ta)\tfinal:\t\t是一个修饰符号\n\tb)\tfinally:\t是跟在try/catch组合后面的，一般用于关闭资源，关闭连接\n\tc)\tfinalize:\tObject类中定义的方法，Java中允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。\n\t \t\t\t这个方法是由垃圾收集器在销毁对象时调用的，通过重写finalize()方法可以整理系统资源或者执行其他清理工作。\n六、\t成员变量和局部变量的区别？\n\t\n\ta)\t成员变量作用于整个类中，存放在内存的堆区。在这个类有效。存于堆中，随着对象产生而存在，消失而消失。\n\tb)\t局部变量作用于方法中，参数上，语句中  存放在内存的栈区，随着所属区域的运行而存在，结束而释放。\n七、\t实例变量和静态变量的区别？\n\n\ta)\t语法上的区别是静态变量前面要加static，实例变量则不用。\n\tb)\t实例变量需要通过创建对象来调用。\n\tc)\t静态变量是由static修饰的变量，可以由类名直接调用，也叫类变量。\n八、\t是否可以从一个静态方法中调用非静态方法？\n\n\ta)\t不可以，因为非静态方法要与对象关联起来，必须创建一个对象后，才可以在该对象上进行方法调用，而static方法调用时不需要创建对象。\n九、\t什么是内部类？作用是什么？内部类有几种？\n\n\ta)\t包裹在外部类的叫做内部类。\n\tb)\t作用是4种：\n\t\t1.\t内部类可以很好的实现隐\n\t\t2.\t内部类拥有外部类的所有元素的访问权限\n\t\t3.\t内部类可以实现多重继承\n\t\t4.\t可以避免修改接口而实现同一个类中两种方法的调用。\n\tc)\t有4种内部类：\n\t\t1.\t成员内部类\n\t\t2.\t局部内部类\n\t\t3.\t匿名内部类\n\t\t4.\t静态内部类\n十、\t构造器可不可以重写？\n\n\t\ta)\t不可以，因为构造器不能被继承，所以不能被重写，但是可以被重载。\n十一、\tError和exception有什么区别？\n\n\ta)\tError表示不是不可能但是很困难恢复情况下的一种问题，比如说内存溢出，服务器宕机等。\n\tb)\tException表示一种设计或实现问题，也就是说，如果程序正常，它是绝对不会出现的问题。\n\n十二、\t列出一些你常见的运行时异常？\n\n\t- ArithmeticException\t\t（算术异常） \n\t- ClassCastException \t\t（类转换异常） \n\t-IllegalArgumentException  （非法参数异常） \n\t-IndexOutOfBoundsException （下标越界异常） \n\t- NullPointerException \t\t（空指针异常） \n\t- SecurityException \t\t（安全异常）\n十三、\t接口和抽象类的区别？\n\n\ta)\t构造方法：抽象类有，接口没有\n\tb)\t成员变量：抽象类有，接口没有\n\tc)\t普通方法：抽象类有，接口没有\n\td)\t静态方法：抽象类有，接口没有\n\te)\t访问类型：public protected private  接口：public\n\tf)\t一个类可以实现多个接口，但只能继承一个抽象类。\n十四、\t创建线程有几种方式？分别是什么？\n\n\ta)\t2种：\n\t1.\t继承Thread类\n\t2.\t实现Runnable接口\n\tb)\t补充：Java 5以后创建线程还有第三种方式：实现Callable接口，该接口中的call方法可以在线程执行结束时产生一个返回值 \n十五、\t创建线程时继承Thread类和实现Runnable接口有什么异同，推荐使用那一种？\n\n\ta)\t同：都有重写run方法来定义线程行为。\n\tb)\t推荐使用后者：因为java中的继承是单一继承，显然使用Runnable更加灵活。\n十六、\t启动一个线程是调用run()还是start()方法？ \n\n\ta)\t用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM 调度并执行，\n\t这并不意味着线程就会立即运行。run()方法是线程启动后要进行回调（callback）的方法。\n十七、\t线程的生命周期？\n\t\n\ta)\t5个阶段：\n\t\t1.\t新建  (new Thread)：\t当创建Thread类的一个实例（对象）时，此线程进入新建状态（未被启动）Thread t1 = new Thead();\t\n\t\t2.\t就绪\t(runnable)：\t线程已经被启动，正在等待被分配给CPU时间片，也就是说此时线程正在就绪队列中排队等候得到CPU资源，\n\t\t3.\t运行\t (running)：\t线程获得CPU资源正在执行任务（run()方法），此时除非此线程自动放弃CPU资源或者有优先级更高的线程进入，线程将一直运行到结束。\n\t\t4.\t阻塞\t (blocked)：\t由于某种原因导致正在运行的线程让出CPU并暂停自己的执行，即进入阻塞状态。\n\t\t5.\t死亡\t   (dead)：\t当线程执行完毕或者被其他线程杀死，线程就进入死亡状态，这时线程不可能再进入就绪状态等待执行。\n十八、\t请说出与线程同步以及线程调度相关的方法？\n\t\n\ta)\t wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁； \n\tb)\t sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理InterruptedException异常；\n\tc)\t notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关； \n\td)\t notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；\n十九、\t线程的sleep()方法和wait()有什么区别？\n\n\ta)\tSleep：休眠，线程的静态方法。将CPU时间片让给其他线程，但是对象锁依然保持，所以休眠时间结束后会自动恢复。\n\tb)\tWait：等待，会导致当前线程放弃对象的锁，让线程进入等待池，只有调用对象的notify()方法，\n\t（或者notifyAll()方法）时候才能唤醒等待池中的线程进入等锁池，如果线程重新获得对象的锁就可以进入就绪状态。\n二十、\tList、Set、Map是否都继承与collection接口？\n\n\ta)\t不全是，List/Set是，Map不是。\n二十一、\tList、Set、Map有什么区别？\n\n\ta)\tList：\t有序可重复  可迭代器遍历\n\tb)\tSet：\t无序不重复\t可迭代器遍历\n\tc)\tMap：\t键值对形式，无序，Key不可重复，Value可以重复\t先遍历Key再遍历Value\n二十二、\tHashMap和HashTable的区别？\n\t\n\ta)\tHashMap是HashTable的轻量级实现。\n\tb)\t线程安全：\t\tHashTable 安全，HashMap不安全\n\tc)\t执行效率：\t\tHashTable慢，HashMap快\n\td)\t对Null存储：\tHashTable不允许，HashMap允许存NULL键值对\n二十三、\tJava有几种类型的流？分别继承于什么？\n\n\ta)\t2种：\n\t\t1.\t字节流：继承于：InputStream/OutputStream\n\t\t2.\t字符流：继承于：Reader/Writer\n二十四、\tString  StringBuilder  StringBuffer的区别？\n\n\ta)\tString是由final所修饰的类，所以String是不可变的字符串常量，使用字符串拼接时是不同的两个空间。\n\tb)\tStringBuffer是可以改变的字符串变量，可以通过append直接在字符串后面追加，是线程安全的\n\tc)\tStringBuffer是可以改变的字符串变量，可以通过append直接在字符串后面追加，是线程不安全的\n\td)\t执行效率StringBuffer执行效率最高。\n二十五、\t阐述JDBC操作数据库的步骤。 \n\n\ta)\t分5步：\n\t\t1.\t加载驱动\n\t\t2.\t创建连接\n\t\t3.\t创建语句\n\t\t4.\t执行语句\n\t\t5.\t处理结果\n\t\t6.\t关闭资源\n二十六、\tStatement和PreparedStatement有什么区别？哪个性能更好？\n\t\n\ta)\tPreparedStatement可减少SQL编译错误，增加SQL安全性，也就是放在SQL注入攻击。\n\tb)\t当批量处理SQL或频繁执行相同的查询时，PreparedStatement有明显的性能更快。\n\n二十七、\t什么是SQL注入攻击？\n\t\n\ta)\t就是攻击者把SQL命令插入到Web表单的输入域或页面请求的查询字符串，欺骗服务器执行恶意的SQL命令\n二十八、\t请简述你了解的几个排序方法，最少说出3个，并写出其中一个？\n\n\ta)\t冒泡排序，选择排序，插入排序，希尔排序\n二十九、\t什么是事务？事务的ACID四个特性分别是什么？举个生活当中的例子说明下什么是事务？\n\n\ta)\t事务就是指作为单个逻辑工作单元执行的一系列操作，同步发生数据更新时，防止数据的不一致。\n\tb)\tACID：\n\t\t1.\t 原子性(Atomic)：\t\t事务中各项操作，要么全做要么全不做，任何一项操作的失败都会导致整个事务的失败； \n\t\t2.\t 一致性(Consistent)：\t事务结束后系统状态是一致的； \n\t\t3.\t 隔离性(Isolated)：\t\t并发执行的事务彼此无法看到对方的中间状态；\n\t\t4.\t 持久性(Durable)：\t\t事务完成后所做的改动都会被持久化，即使发生灾难性的失败。通过日志和同步备份可以在故障发生后重建数据。\n三十、\t什么是索引？如何创建索引？举个生活中的例子来诠释索引？\n\t\n\ta)\t索引是一种可以直接访问数据库表中某一数据行的树型结构，为了提高查询效率而引入的，是独立与表的对象。\n\tb)\tCreate index 索引名\n\n\n一、\tJSP技术优缺点？\na)\t优点：\n1.\tJSP代码跨平台\n2.\tJSP组件跨平台\n3.\t支持多种网页格式\n4.\tJSP标签可扩充性\nb)\t缺点：\n1.\tJSP技术极大的增加了产品的复杂性。\n2.\tJSP程序调试很困难\n二、\t\nweb.xml文件中可以配置哪些内容？\na)\tweb.xml用于配置Web应用的相关信息，如：监听器（listener）、过滤器（filter）、 Servlet、相关参数、会话超时时间、安全验证方式、错误页面等。\n\n","tags":["面试资料"],"categories":["interview"]},{"title":"HTTP状态码说明","url":"/2017/10/30/HTTP状态码说明/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\nHTTP状态码说明\n<!-- more -->\n<The rest of contents | 余下全文>\n\nHTTP状态码（HTTP Status Code）是用以表示网页服务器HTTP响应状态的3位数字代码。当我们打开一个网页时，如果网页能够返回数据，也就是说影响成功了，一般状态响应码都是200。当然状态响应码，包括很多内容，下面列举了，状态响应码，及其表示的含义:\n\n\n\n\t100：继续 客户端应当继续发送请求。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。\n\t101： 转换协议 在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。只有在切换新的协议更有好处的时候才应该采取类似措施。\n\t102：继续处理 由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。\n\t200：请求成功 处理方式：获得响应的内容，进行处理 \n\t201：请求完成，结果是创建了新资源。新创建资源的URI可在响应的实体中得到 处理方式：爬虫中不会遇到 \n\t202：请求被接受，但处理尚未完成 处理方式：阻塞等待 \n\t204：服务器端已经实现了请求，但是没有返回新的信 息。如果客户是用户代理，则无须为此更新自身的文档视图。 处理方式：丢弃 \n\t300：该状态码不被HTTP/1.0的应用程序直接使用， 只是作为3XX类型回应的默认解释。存在多个可用的被请求资源。 处理方式：若程序中能够处理，则进行进一步处理，如果程序中不能处理，则丢弃 \n\t301：请求到的资源都会分配一个永久的URL，这样就可以在将来通过该URL来访问此资源 处理方式：重定向到分配的URL \n\t302：请求到的资源在一个不同的URL处临时保存 处理方式：重定向到临时的URL \n\t304：请求的资源未更新 处理方式：丢弃 \n\t400：非法请求 处理方式：丢弃 \n\t401：未授权 处理方式：丢弃 \n\t403：禁止 处理方式：丢弃 \n\t404：没有找到 处理方式：丢弃 \n\t500：服务器内部错误 服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器端的源代码出现错误时出现。 \n\t501：服务器无法识别 服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。 \n\t502：错误网关 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。 \n\t503：服务出错 由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。","tags":["HTTP状态码说明"],"categories":["servicer"]},{"title":"IDEA快捷键","url":"/2017/10/30/软件Intellij IDEA 快捷键整理/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\nIDEA快捷键\n<!-- more -->\n<The rest of contents | 余下全文>\n【常规】\n\n\tCtrl+Shift + Enter，语句完成\n\t“！”，否定完成，输入表达式时按 “！”键\n\tCtrl+E，最近的文件\n\tCtrl+Shift+E，最近更改的文件\n\tShift+Click，可以关闭文件\n\tCtrl+[ OR ]，可以跑到大括号的开头与结尾\n\tCtrl+F12，可以显示当前文件的结构\n\tCtrl+F7，可以查询当前元素在当前文件中的引用，然后按 F3 可以选择\n\tCtrl+N，可以快速打开类\n\tCtrl+Shift+N，可以快速打开文件\n\tAlt+Q，可以看到当前方法的声明\n\tCtrl+P，可以显示参数信息\n\tCtrl+Shift+Insert，可以选择剪贴板内容并插入\n\tAlt+Insert，可以生成构造器/Getter/Setter等\n\tCtrl+Alt+V，可以引入变量。例如：new String();  自动导入变量定义\n\tCtrl+Alt+T，可以把代码包在一个块内，例如：try/catch\n\tCtrl+Enter，导入包，自动修正\n\tCtrl+Alt+L，格式化代码\n\tCtrl+Alt+I，将选中的代码进行自动缩进编排，这个功能在编辑 JSP 文件时也可以工作\n\tCtrl+Alt+O，优化导入的类和包\n\tCtrl+R，替换文本\n\tCtrl+F，查找文本\n\tCtrl+Shift+Space，自动补全代码\n\tCtrl+空格，代码提示（与系统输入法快捷键冲突）\n\tCtrl+Shift+Alt+N，查找类中的方法或变量\n\tAlt+Shift+C，最近的更改\n\tAlt+Shift+Up/Down，上/下移一行\n\tShift+F6，重构 - 重命名\n\tCtrl+X，删除行\n\tCtrl+D，复制行\n\tCtrl+/或Ctrl+Shift+/，注释（//或者/**/）\n\tCtrl+J，自动代码（例如：serr）\n\tCtrl+Alt+J，用动态模板环绕\n\tCtrl+H，显示类结构图（类的继承层次）\n\tCtrl+Q，显示注释文档\n\tAlt+F1，查找代码所在位置\n\tAlt+1，快速打开或隐藏工程面板\n\tCtrl+Alt+left/right，返回至上次浏览的位置\n\tAlt+left/right，切换代码视图\n\tAlt+Up/Down，在方法间快速移动定位\n\tCtrl+Shift+Up/Down，向上/下移动语句\n\tF2 或 Shift+F2，高亮错误或警告快速定位\n\tTab，代码标签输入完成后，按 Tab，生成代码\n\tCtrl+Shift+F7，高亮显示所有该文本，按 Esc 高亮消失\n\tAlt+F3，逐个往下查找相同文本，并高亮显示\n\tCtrl+Up/Down，光标中转到第一行或最后一行下\n\tCtrl+B/Ctrl+Click，快速打开光标处的类或方法（跳转到定义处）\n\tCtrl+Alt+B，跳转到方法实现处\n\tCtrl+Shift+Backspace，跳转到上次编辑的地方\n\tCtrl+O，重写方法\n\tCtrl+Alt+Space，类名自动完成\n\tCtrl+Alt+Up/Down，快速跳转搜索结果\n\tCtrl+Shift+J，整合两行\n\tAlt+F8，计算变量值\n\tCtrl+Shift+V，可以将最近使用的剪贴板内容选择插入到文本\n\tCtrl+Alt+Shift+V，简单粘贴\n\tShift+Esc，不仅可以把焦点移到编辑器上，而且还可以隐藏当前（或最后活动的）工具窗口\n\tF12，把焦点从编辑器移到最近使用的工具窗口\n\tShift+F1，要打开编辑器光标字符处使用的类或者方法 Java 文档的浏览器\n\tCtrl+W，可以选择单词继而语句继而行继而函数\n\tCtrl+Shift+W，取消选择光标所在词\n\tAlt+F7，查找整个工程中使用地某一个类、方法或者变量的位置\n\tCtrl+I，实现方法\n\tCtrl+Shift+U，大小写转化\n\tCtrl+Y，删除当前行\n\tShift+Enter，向下插入新行\n\tpsvm/sout，main/System.out.println(); Ctrl+J，查看更多\n\tCtrl+Shift+F，全局查找\n\tCtrl+F，查找/Shift+F3，向上查找/F3，向下查找\n\tCtrl+Shift+S，高级搜索\n\tCtrl+U，转到父类\n\tCtrl+Alt+S，打开设置对话框\n\tAlt+Shift+Inert，开启/关闭列选择模式\n\tCtrl+Alt+Shift+S，打开当前项目/模块属性\n\tCtrl+G，定位行\n\tAlt+Home，跳转到导航栏\n\tCtrl+Enter，上插一行\n\tCtrl+Backspace，按单词删除\n\tCtrl+\"+/-\"，当前方法展开、折叠\n\tCtrl+Shift+\"+/-\"，全部展开、折叠\n\n【调试部分、编译】\n\n\tCtrl+F2，停止\n\tAlt+Shift+F9，选择 Debug\n\tAlt+Shift+F10，选择 Run\n\tCtrl+Shift+F9，编译\n\tCtrl+Shift+F10，运行\n\tCtrl+Shift+F8，查看断点\n\tF8，步过\n\tF7，步入\n\tShift+F7，智能步入\n\tShift+F8，步出\n\tAlt+Shift+F8，强制步过\n\tAlt+Shift+F7，强制步入\n\tAlt+F9，运行至光标处\n\tCtrl+Alt+F9，强制运行至光标处\n\tF9，恢复程序\n\tAlt+F10，定位到断点\n\tCtrl+F8，切换行断点\n\tCtrl+F9，生成项目\n\tAlt+1，项目\n\tAlt+2，收藏\n\tAlt+6，TODO\n\tAlt+7，结构\n\tCtrl+Shift+C，复制路径\n\tCtrl+Alt+Shift+C，复制引用，必须选择类名\n\tCtrl+Alt+Y，同步\n\tCtrl+~，快速切换方案（界面外观、代码风格、快捷键映射等菜单）\n\tShift+F12，还原默认布局\n\tCtrl+Shift+F12，隐藏/恢复所有窗口\n\tCtrl+F4，关闭\n\tCtrl+Shift+F4，关闭活动选项卡\n\tCtrl+Tab，转到下一个拆分器\n\tCtrl+Shift+Tab，转到上一个拆分器\n\n【重构】\n\n\tCtrl+Alt+Shift+T，弹出重构菜单\n\tShift+F6，重命名\n\tF6，移动\n\tF5，复制\n\tAlt+Delete，安全删除\n\tCtrl+Alt+N，内联\n\n【查找】\n\n\tCtrl+F，查找\n\tCtrl+R，替换\n\tF3，查找下一个\n\tShift+F3，查找上一个\n\tCtrl+Shift+F，在路径中查找\n\tCtrl+Shift+R，在路径中替换\n\tCtrl+Shift+S，搜索结构\n\tCtrl+Shift+M，替换结构\n\tAlt+F7，查找用法\n\tCtrl+Alt+F7，显示用法\n\tCtrl+F7，在文件中查找用法\n\tCtrl+Shift+F7，在文件中高亮显示用法\n\n【VCS】\n\n\tAlt+~，VCS 操作菜单\n\tCtrl+K，提交更改\n\tCtrl+T，更新项目\n\tCtrl+Alt+Shift+D，显示变化","tags":["IDEA"],"categories":["tool"]},{"title":"JDBC","url":"/2017/10/30/数据库JDBC/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\nJDBC\n<!-- more -->\n<The rest of contents | 余下全文>\n##JDBC\n###什么是JDBC\n- Java DataBase Connectivity,java数据库连接，实际上jdbc是java中的一套和数据库交互的api（application program interface 应用程序编程接口）\n###为什么使用JDBC\n![](01.png)\n- 因为java程序员需要连接多种数据库(orcale,mysql,db2等)为了避免每一个数据库都学习一套新的api，sun公司提出了一个jdbc接口，各个数据库厂商根据此接口写实现类（驱动）,这样java程序员只需要掌握JDBC接口中的一套方法，就可以访问任何数据库。\n###如何使用JDBC\n1. 创建maven工程\n2. 下载mysql相关jar包\n\n\t登陆达内的私服：maven.tedu.cn\n\n\t登陆阿里私服：maven.aliyun.com\n\n\t- 首页搜索栏输入mysql 搜索\n\t- 找到5.1.6版本 复制坐标 到自己工程的pom.xml文件里\n3. 创建JDBCDemo1.java类 添加main方法\n4. 使用步骤：\n\t- 注册驱动\n\t- 获取连接对象\n\t- 创建sql执行对象\n\t- 执行sql语句\n\t- 关闭资源\n\n            //1.注册驱动\n            Class.forName(\"com.mysql.jdbc.Driver\");\n            //2.获取连接对象\n            Connection conn = DriverManager.getConnection( \"jdbc:mysql://localhost:3306/db3\", \"root\", \"root\");\n            //3.创建sql执行对象\n            Statement stat = conn.createStatement();\n            //4.执行sql\n            stat.execute(\"drop table if exists jdbct2\");\n            System.out.println(\"删除成功！\");\n            //5. 关闭资源\n            stat.close();\n            conn.close();\n\n####执行sql的方法\n- execute(sql) 可以执行任意sql，但是推荐执行DDL\n\t返回值为boolean值 true代表有结果集 false代表没有结果集，成功或失败通过是否有异常来判断\n- executeUpdate(sql) 推荐执行DML\n\t返回值为int 代表生效行数\n- executeQuery(sql)推荐执行DQL\n\n\tinsert into jdbct1 values(2,'Jerry'),(3,'李白');\n\n\t返回值ResultSet 里面装了查询结果\n\tnext()方法的作用：判断有没有下一条数据有返回值为true（同时游标往下移动） 没有则false\n\n\t\t\t//4.执行sql\n\t\t\t\tResultSet rs =stat.executeQuery(\"select * from jdbct1\");\n\t\t\t\t\t//遍历结果\n\t\t\t\t\twhile(rs.next()){\n\t\t\t\t\t\tint id = rs.getInt(\"id\");\n\t\t\t\t\t\tString name = rs.getString(\"name\");\n\t\t\t\t\t\tSystem.out.println(id+\":\"+name);\n\t\t\t\t\t}\n\n###数据库类型和Java类型对比\n\t\tmysql            \t java\n\t\tint             \t getInt\n\t\tvarchar           \t getString\n\t\tfloat/double    \t getFloat/getDouble\n\t\tdatetime/timestamp   getDate\n###ResultSet获取数据的方式\n1. 通过字段名获取  如：getString(\"name\")\n2. 通过查询到结果数据的位置获取 如：getString(2); 位置从1开始\n\n###读取配置文件\n        //创建读取配置文件的对象\n\t\tProperties prop = new Properties();\n\t\t//获取文件输入流\n\t\tInputStream ips =DBUtils.class.getClassLoader().getResourceAsStream(\"jdbc.properties\");\n\t\t//把文件加载到对象中\n\t\ttry {\n\t\t\tprop.load(ips);\n\t\t\t//读取连接数据库的信息\n\t\t\tdriver = prop.getProperty(\"driver\");\n\t\t\turl = prop.getProperty(\"url\");\n\t\t\tusername = prop.getProperty(\"username\");\n\t\t\tpassword = prop.getProperty(\"password\");\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n###数据库连接池\n- DBCP DataBase Connection Pool:数据库连接池\n- 为什么使用：如果没有连接池，每一次业务都需要和数据库服务器建立一次连接，业务处理完断开连接，如果有上万次业务就会有上万次的开关连接，频繁开关连接非常浪费资源，使用数据库连接池，可以设置几个初始连接，如果有业务需要使用连接，则从连接池中直接获取，如果连接池中连接用光，则会等待连接归还后再获取连接\n\n- 如何使用：\n1. 下载jar包： 从maven私服中搜索 dbcp\n\n2. 代码：\n\n\n\t\tdataSource.setDriverClassName(\"com.mysql.jdbc.Driver\");\n\t\tdataSource.setUrl(\"jdbc:mysql://localhost:3306/db3\");\n\t\tdataSource.setUsername(\"root\");\n\t\tdataSource.setPassword(\"root\");\n\t\t//3. 设置连接池策略信息\n\t\tdataSource.setInitialSize(3);//初始连接数量\n\t\tdataSource.setMaxActive(5);//最大连接数量\n\n\t\t//4.从连接池中获取连接对象\n\t\tConnection conn = dataSource.getConnection();\n\t\tSystem.out.println(conn);\n\n\n###解决jdbc乱码问题\n\n在url后面添加如下内容\n\n    jdbc:mysql://localhost:3306/db3?useUnicode=true&characterEncoding=UTF-8\n\n\n\n###Properties属性配置文件\n- 代码参见：demo03.java\n\n###PreparedStatement\n- 好处：\n1. 相比较Statement 代码结构整齐，可读性高。\n2. 可以避免SQL注入，因为在编译的时候已经把SQL的逻辑固定，替换？时如果有修改逻辑的语句如or 则不会生效 \n3. 如果执行大量的SQL语句 preparedstatement 执行效率略高于statement\n\n- 如果SQL中有变量则使用preparedStatement，没有变量则可以使用statement\n\n###批量操作\n- 代码参见：demo06.java  demo07.java\n\n###分页查询\n- 代码参见：demo08.java\n\n###事务 \n- 代码参见：demo09.java\n\n###获取自增主键值\n\n###乱码问题\n在url后面添加以下内容\njdbc:mysql://localhost:3306/db3?useUnicode=true&characterEncoding=UTF-8\n\n\n###元数据\n- 数据库元数据: 一些和数据库相关的信息如：数据库版本信息，数据库厂商等\n- 表元数据: 一些和表相关的信息：表字段的数量，字段名称，字段类型等\n","tags":["JDBC"],"categories":["after-end"]},{"title":"Linux查看系统配置常用命令","url":"/2017/10/30/Linux查看系统配置常用命令/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\nLinux查看系统配置常用命令\n<!-- more -->\n<The rest of contents | 余下全文>\n\n**系统**\n\n\t\t head -n 1 /etc/issue    查看操作系统版本\n\t\t cat /proc/cpuinfo       查看CPU信息\n\t\t hostname                查看计算机名\n\t\t lspci -tv               列出所有PCI设备\n\t\t lsusb -tv               列出所有USB设备\n\t\t lsmod                   列出加载的内核模块\n\t\t env                     查看环境变量\n\n**资源**\n\n\t\t free -m                 查看内存使用量和交换区使用量\n\t\t df -h                   查看各分区使用情况\n\t\t du -sh <目录名>          查看指定目录的大小\n\t\t grep MemTotal /proc/meminfo    查看内存总量\n\t\t grep MemFree /proc/meminfo     查看空闲内存量\n\t\t uptime                  查看系统运行时间、用户数、负载\n\t\t cat /proc/loadavg       查看系统负载\n\n**磁盘和分区**\n\n\t\t mount | column -t       查看挂接的分区状态\n\t\t fdisk -l                查看所有分区\n\t\t swapon -s               查看所有交换分区\n\t\t hdparm -i /dev/hda      查看磁盘参数(仅适用于IDE设备)\n\t\t dmesg | grep IDE        查看启动时IDE设备检测状况\n\n**网络**\n\n\t\t ifconfig                查看所有网络接口的属性\n\t\t iptables -L             查看防火墙设置\n\t\t route -n                查看路由表\n\t\t netstat -lntp           查看所有监听端口\n\t\t netstat -antp           查看所有已经建立的连接\n\t\t netstat -s              查看网络统计信息\n\n**进程**\n\n\t\tps -ef                  查看所有进程\n\t\ttop                     实时显示进程状态\n\n**用户**\n\n\t\t w                     \t    查看活动用户\n\t\t id <用户名>           \t  查看指定用户信息\n\t\t last                   \t查看用户登录日志\n\t\t cut -d: -f1 /etc/passwd    查看系统所有用户\n\t\t cut -d: -f1 /etc/group     查看系统所有组\n\t\t crontab -l                 查看当前用户的计划任务\n\n**服务**\n\n\t\t chkconfig --list              列出所有系统服务\n\t\t chkconfig --list | grep on    列出所有启动的系统服务\n\n**程序**\n\n\t\trpm -qa                        查看所有安装的软件包","tags":["Linux"],"categories":["servicer"]},{"title":"Excel","url":"/2017/10/30/excel/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\nExcel\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\t\n\t性别:IF(MOD(B9,17,1),2)=1,\"男\",\"女\")\n\t生日:TEXT(MOD(B9,7,8),\"0000-00-00\")","tags":["Excel"],"categories":["assist"]},{"title":"WebStrom快捷键","url":"/2017/10/30/软件WebStrom快捷键/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\nWebStrom快捷键\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\tCtrl+/ 或 Ctrl+Shift+/-----------------------------------------------注释（// 或者/*…*/ ）\n\tShift+F6-------------------------------------------------------------重构-重命名\n\tCtrl+X-------------------------------------------------------------- 删除行\n\tCtrl+D---------------------------------------------------------------复制行\n\tCtrl+G---------------------------------------------------------------查找行\n\tCtrl+Shift+Up/Down---------------------------------------------------代码向上/下移动。\n\tF2 或Shift+F2---------------------------------------------------------高亮错误或警告快速定位\n\t写代码，按Tab----------------------------------------------------------生成代码\n\t选中文本，按Ctrl+Shift+F7------------------------------------------高亮显示所有该文本，按Esc高亮消失。(因为这个功能我就可以发放心的放弃sublime了)\n\tCtrl+B或Ctrl+鼠标左键单击------------------------------------------快速打开光标处的类或方法，（NB的功能）\n\tCtrl + Alt + B\t-------------------------------------------------Go to implementation(s) 跳转方法实现处\n\tCtrl + Shift + I\t---------------------------------------------Open quick definition lookup 打开定义快速查找\n\tAlt + Up/Down\t-------------------------------------------------Go to previous/next method 跳转到上一个/下一个方法\n\tCtrl+E-----------------------------------------------------------最近打开的文件\n\tAlt+F1-----------------------------------------------------------查找代码所在位置\n\tCtrl+Alt+L-------------------------------------------------------格式化代码\n\tCtrl+R-----------------------------------------------------------替换文本\n\tCtrl+F-----------------------------------------------------------查找文本\n\tCtrl+P-----------------------------------------------------------方法参数提示\n\tF3---------------------------------------------------------------查找下一个\n\tShift+F3---------------------------------------------------------查找上一个\n\talt+Shift+F------------------------------------------------------将当前文件加入收藏夹\n\tctrl+alt+s-------------------------------------------------------打开配置窗口\n\tctrl+Shift+N-----------------------------------------------------通过文件名快速查找工程内的文件（必记）\n\tctrl+Shift+alt+N-------------------------------------------------过一个字符快速查找位置（必记）\n\tShift+enter------------------------------------------------------重新开始一行（无论光标在哪个位置）\n\tCtrl + Alt + T----------------------------with…（if, else, try, catch, for, etc）用 * 来围绕选中的代码行，（ * 包括 if 、 while 、 try catch 等）\n\tCtrl + Shift + U-------------------------------------------------Toggle case for word at caret or selected block 光标所在位置大小写\n\tCtrl + Delete----------------------------------------------------Delete to word end 删除文字结束\n\tCtrl + Backspace-------------------------------------------------Delete to word start 删除文字开始\n\tCtrl + E---------------------------------------------------------Recent files popup 弹出最近打开的文件\n\tF11\tToggle bookmark----------------------------------------------切换标记，我觉得叫书签更好，就是sublime text 的F2\n\tCtrl + Shift + F12-----------------------------------------------Toggle maximizing editor 切换最大化编辑器\n\tAlt + Shift + F--------------------------------------------------Add to Favorites 添至收藏夹","tags":["WebStrom"],"categories":["tool"]}]