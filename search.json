[{"title":"用户名、密码等15个常用的js正则表达式","url":"/2018/09/21/正则表达式/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n用户名、密码等15个常用的js正则表达式\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n**1 用户名正则**\n\n//用户名正则，4到16位（字母，数字，下划线，减号）\n\n\tvar uPattern = /^[a-zA-Z0-9_-]{4,16}$/;\n//输出 true\n\n\tconsole.log(uPattern.test(\"iFat3\"));\n** 2 密码强度正则**\n\n//密码强度正则，最少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符\n\n\tvar pPattern = /^.*(?=.{6,})(?=.*\\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&*? ]).*$/;\n//输出 true\n\n\tconsole.log(\"==\"+pPattern.test(\"iFat3#\"));\n\n**3 整数正则**\n\n//正整数正则\n\n\tvar posPattern = /^\\d+$/;\n//负整数正则\n\n\tvar negPattern = /^-\\d+$/;\n//整数正则\n\n\tvar intPattern = /^-?\\d+$/;\n//输出 true\n\n\tconsole.log(posPattern.test(\"42\"));\n//输出 true\n\n\tconsole.log(negPattern.test(\"-42\"));\n//输出 true\n\n\tconsole.log(intPattern.test(\"-42\"));\n\n**4 数字正则**\n\n可以是整数也可以是浮点数\n\n//正数正则\n\n\tvar posPattern = /^\\d*\\.?\\d+$/;\n//负数正则\n\n\tvar negPattern = /^-\\d*\\.?\\d+$/;\n//数字正则\n\n\tvar numPattern = /^-?\\d*\\.?\\d+$/;\n\tconsole.log(posPattern.test(\"42.2\"));\n\tconsole.log(negPattern.test(\"-42.2\"));\n\tconsole.log(numPattern.test(\"-42.2\"));\n**5 Email正则**\n\n//Email正则\n\n\tvar ePattern = /^([A-Za-z0-9_\\-\\.])+\\@([A-Za-z0-9_\\-\\.])+\\.([A-Za-z]{2,4})$/;\n//输出 true\n\n\tconsole.log(ePattern.test(65974040@qq.com));\n\n**6 手机号码正则**\n\n//手机号正则\n\n\tvar mPattern = /^((13[0-9])|(14[5|7])|(15([0-3]|[5-9]))|(18[0,5-9]))\\d{8}$/;\n//输出 true\n\n\tconsole.log(mPattern.test(\"18600000000\"));\n\n**7 身份证号正则**\n\n//身份证号（18位）正则\n\n\tvar cP = /^[1-9]\\d{5}(18|19|([23]\\d))\\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\\d{3}[0-9Xx]$/;\n//输出 true\n\n\tconsole.log(cP.test(\"11010519880605371X\"));\n\n**8 URL正则**\n\n//身份证号（18位）正则\n\n\tvar cP = /^[1-9]\\d{5}(18|19|([23]\\d))\\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\\d{3}[0-9Xx]$/;\n//输出 true\n\n\tconsole.log(cP.test(\"11010519880605371X\"));\n\n**9 IPv4地址正则**\n\n//ipv4地址正则\n\n\tvar ipP = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;\n//输出 true\n\n\tconsole.log(ipP.test(\"115.28.47.26\"));\n**10 十六进制颜色正则**\n\n//RGB Hex颜色正则\n\tvar cPattern = /^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/;\n//输出 true\n\n\tconsole.log(cPattern.test(\"#b8b8b8\"));\n\n**11 日期正则**\n\n//日期正则，简单判定,未做月份及日期的判定\n\n\tvar dP1 = /^\\d{4}(\\-)\\d{1,2}\\1\\d{1,2}$/;\n\n//输出 true\n\n\tconsole.log(dP1.test(\"2017-05-11\"));\n\n//输出 true\n\n\tconsole.log(dP1.test(\"2017-15-11\"));\n\n//日期正则，复杂判定\n\n\tvar dP2 = /^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$/;\n\n//输出 true\n\n\tconsole.log(dP2.test(\"2017-02-11\"));\n\n//输出 false\n\n\tconsole.log(dP2.test(\"2017-15-11\"));\n\n//输出 false\n\n\tconsole.log(dP2.test(\"2017-02-29\"));\n\n**12 QQ号码正则**\n\n//QQ号正则，5至11位\n\n\tvar qqPattern = /^[1-9][0-9]{4,10}$/;\n//输出 true\n\n\tconsole.log(qqPattern.test(\"65974040\"));\n\n**13 微信号正则**\n\n//微信号正则，6至20位，以字母开头，字母，数字，减号，下划线\n\n\tvar wxPattern = /^[a-zA-Z]([-_a-zA-Z0-9]{5,19})+$/;\n\n//输出 true\n\n\tconsole.log(wxPattern.test(\"RuilongMao\"));\n\n**14 车牌号正则**\n\n//车牌号正则\n\n\tvar cPattern = /^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]{1}[A-Z]{1}[A-Z0-9]{4}[A-Z0-9挂学警港澳]{1}$/;\n//输出 true\n\n\tconsole.log(cPattern.test(\"京K39006\"));\n\n**15 包含中文正则**\n\n//包含中文正则\n\n\tvar cnPattern = /[\\u4E00-\\u9FA5]/;\n//输出 true\n\n\tconsole.log(cnPattern.test(\"42度\"));","tags":["js正则表达式"],"categories":["front-end"]},{"title":"WEB前端HTML","url":"/2018/08/30/前端HTML/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\nWEB前端\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n###HTML\n\tHyper Text Markup Language：超文本标记语言 \n- 什么是超文本：不仅仅是文本，还包括文本的字体颜色，样式 还包括多媒体（图片，音频，视频）\n- html学习内容： 学习有哪些固定的标签，还有标签内部有哪些属性和标签和标签之间的嵌套关系\n\n###通过Eclipse创建html文件 \n- 新建文件-> other->搜索html \n\n###html结构\n\n\t\t<!DOCTYPE html>   //文档声明 告诉浏览器使用html的哪个版本来解析页面内容 ，此写法是告诉浏览器用最新的html5的版本解析 \n\t\t<html>//所有内容都在html标签内部 除了 文档声明\n\t\t\t<head>//头 ：里面的内容是给浏览器看的 比如使用什么编码 \n\t\t\t</head>\n\t\t\t<body>//体 ：里面的内容是给用户看的 \n\t\t\t</body>\n\t\t</html>\n####head里面的标签\n\n\t\t<meta charset=\"UTF-8\">：告诉浏览器使用哪种字符集解析\n\n\t\t<title>Insert title here</title> 告诉浏览器 页面标题是什么，title还可以起到优化SEO的作用（让搜索引擎尽快搜索到此页面）\n\t\t keywords的作用：让搜索引擎尽快的找到本页面\n\n###Body内部的标签\n####文本标签\n\t\t\n\t\t1. <h1></h1>.......<h6></h6> 内容标题\n\t\t- align：left/center/right  水平对齐方式\n\t\t2. <p></p>    段落标签 ，每个段落标签独占一行并且上下会留有空白区域\n\t\t3. <hr> 水平分割线\n\t\t4. <br> 换行\n####列表标签\n\t\t\n1. 无序列表：\n \n\t\t\t<ul type=\"circle\"> <!-- u:unordered 无序 l:list 列表 -->\n\t\t\t\t<li>刘备</li><!--l:list列表 i:item 项  -->\n\t\t\t\t<li>貂蝉</li>\n\t\t\t\t<li>孙尚香</li>\n\t\t\t\t<li>孙悟空</li>\n\t\t\t</ul>\n\n2. 有序列表\n\t\t\t\n\t\t\t<ol>\n\t\t\t\t<li>打开冰箱门</li> \n\t\t\t\t<li>把大象装进去</li>\n\t\t\t\t<li>关上冰箱门</li>\n\t\t\t\t<li>啦啦啦</li>\n\t\t\t</ol>\n- 常见属性： type 控制每个列表项前面的表示的（a A i I 1默认） start 列表数值的起始值  reversed 倒序\n\t\t\n3. 定义列表\n\n\t\t<h3>定义列表</h3>\n\t\t<dl><!-- defined list 定义一个列表 -->\n\t\t\t<dt>凉菜</dt><!--defined title 定义标题 -->\n\t\t\t<dd>老醋花生</dd><!--defined data 定义数据  -->\n\t\t\t<dd>花毛一体</dd>\n\t\t\t<dd>大拌菜</dd>\n\t\t\t<dt>炒菜</dt>\n\t\t\t<dd>宫保鸡丁</dd>\n\t\t\t<dd>小炒肉</dd>\n\t\t\t<dd>木须肉</dd>\n\t\t</dl>\n \n4. 列表嵌套\n- 有序和无序列表可以任意嵌套多层\n\n###分区标签（元素） div和span \n- 对页面进行分区有两大好处：\n1. 可以多个页面复用同一个区域的内容\n2. 可以对整个区域的内容进行统一管理\n- 分区元素本身没有显示效果，起到容器的作用\n- div： 块级分区 独占一行 \n- span： 行内分区 和多个行内分区元素 共占一行 \n- 通常一个页面会分为三大区域\n\t\t\n\t\t<body>\n\t\t\t<div>头部区域</div>\n\t\t\t<div>正文区域</div>\n\t\t\t<div>尾/脚部区域</div>\n\t\t</body>\n- 在html5中提出了几个分区元素 效果和div一样，但是代码可读性增强了\n\t\t<body>\n\t\t\t<header>头部区域</header>\n\t\t\t<article>正文区域</article>\n\t\t\t<footer>脚部区域</footer>\n\t\t</body>\n####元素的分类\n- 块级元素：独占一行\n\t包括： h1-h6, p,div,hr\n- 行内元素：和多个行内元素共占一行\n\t包括：span, <i></i>和 <em></em>（斜体）<b></b>和<strong></strong>(粗体)  <u></u>下划线   <s></s>和<del></del>删除线\n####行内元素空格折叠现象\n- 行内元素中空格如果有多个只能识别一个空格\n####需要转义的常见特殊字符 实体引用\n- 空格： &nbsp;\n- < : &lt;\n- > : &gt;\n- 换行：<br>\n\n###图片元素\n- <img>属于单标签\n- 常见属性：\n1. alt：当图片不能正常显示的时候显示此文本\n2. src：写图片的路径，路径分为两种：\n- 绝对路径：以http开头的路径，此路径可以指向本网站也可以指向其它网站(盗链，盗链图片如果原网站图片发生改变则不能正常显示)\n- 相对路径：相对于当前页面html文件 1. 图片和页面文件在同一个文件夹下，直接写文件名，2. 图片在页面文件的上一层文件夹 ../文件名  3. 在页面文件的下一层文件夹  文件夹名/文件夹名/文件名\n- 路径总结： 如果是站内资源使用相对路径，站外资源使用绝对路径\n- 图床：专门存放图片的网站，使用图床可以节省本站空间\n3. title:图片标题 当鼠标悬停在图片上面的时候显示\n4. width：设置图片的宽度，两种方式：像素和百分比，如果只设置宽度 高度会保证宽高比的情况下自动跟着宽度改变\n5. height: 设置图片的高度，两种方式：像素和百分比。\n\n- img支持的图片格式： jpg  png  gif\n\n\n\n####Map 图像地图\n- 什么是图像地图： 可以将图片的某个区域作为可点击的链接\n- 使用方式：\n\n\t\t<!-- usemap:使用地图 #代表当前页面 -->\n\t\t<img alt=\"\" src=\"../imgs/b.jpg\" usemap=\"#mymap\">\n\t\t<!-- 为了保证兼容性问题 把name和id都写上  -->\n\t\t<map name=\"mymap\" id=\"mymap\">\n\t\t\t<!-- area区域  shape形状 rect矩形 coords坐标-->\n\t\t\t<area shape=\"rect\" coords=\"0,0,200,200\" \n\t\t\t\t\thref=\"../imgs/2.gif\">\n\t\t\t<area shape=\"circle\" coords=\"663,473,90\"\n\t\t\t\t href=\"../imgs/d.jpg\">\n\t\t</map>\n- map中的id和name作用是让图片能够找得到此地图\n- area常见属性： shape表示形状 常用有circle和rect\n- href：值为一个路径，可以写相对路径和绝对路径，路径可以指向页面，也可以指向文件（浏览器可以打开的文件直接浏览，不能打开的文件则下载）\n\n###超链接 a标签\n- 如果a标签没有添加href属性 就相当于一个文本不是超链接\n- href属性和图像地图中的href作用一样\n- target=\"_blank\" 开启一个新的页面\n- 锚点用法： 需要先创建锚点:<a id=\"a\" name=\"a\"></a>, 然后通过a标签跳转到锚点的位置：<a href=\"#a\">跳转到锚点</a>\n- img标签放在a标签内部 则图片就可以被点击了\n###练习：1号美女  2号美女   3号美女    4号帅哥\n\n###表格 table\n- 接触标签有 table tr td\n- table的属性：align水平对齐 width宽度 border边框 cellspacing边框和单元格的距离 cellpadding内容和单元格的距离 \n- td的属性：colspan跨列  rowspan跨行 align水平对齐\n- caption标签\n- 分组标签：<thead> <tbody> <tfoot>  没有任何显示效果，提高代码可读性\n\n###表单\n- 表单的作用是收集用户的数据提交到服务端\n- 表单中的控件包括： 文本框、密码框、按钮、下拉列表、单选、复选、时间选择、文件选择、文本域\n####文本框 \n\n\t\t<input type=\"text\" placeholder=\"占位文本\" maxlength=\"最大字符长度\" readonly=\"只读\" >\n####密码框\n\n\t\t<input type=\"password\" maxlength>\n\n####单选\n\n\t\t<input type=\"radio\" checked默认选中>\n\n####多选、复选框\n\n\t\t<input type=\"checkbox\" id=\"aaa\">  <label for=\"aaa\">xxx</label>\n\n####时间\n\n\t\t<input type=\"date\" >\n\n####文件\n\n\t\t<input type=\"file\" >\n\n####下拉选\n\n\t\t<select name>\n\t\t\t\t<option value selected></option>\n\t\t<select>\n\n####文本域 \n\t\n\t\t<textarea rows=\"行数\" cols=\"列数\"></textarea>\n\n####隐藏域\n\n\t\t<input type=\"hidden\">\n\n####按钮\n\n\t\t<input type=\"submit/reset/button\" value=\"按钮标题\">\n####代码\n1. 图像地图Map  \n\t\t\t\n\t\t<img usemap=\"#mymap\">\n\t\t<map name=\"mymap\" id=\"mymap\">\n\t\t<area shape=\"rect/circle\" coords=\"\" href=\"\"></area>\n\t\t</map>\n\n2. 超链接 a\n\t\t\n\t\t<a href=\"\" target=\"_blank\">超链接</a>\n\t\t<a id name ></a>   <a href=\"#id/name\">跳转</a>\n3. 表格 \n\t\n\t\t<table border cellspacing cellpadding width align>\n\t\t<tr>行\n\t\t<td rowspan  colspan align>列\n\t\t<th>表头\n\t\t<thead> <tbody> <tfoot>  \n\t\t<caption> 表的标题\n\n4. 表单  文本框 密码框 单选 多选  文件 日期  隐藏域 按钮 下拉选 文本域\n\n\t\t<input type=\"text/password/radio/checkbox/file/date/hidden/submit/reset/button\" name value id checked placeholder readonly maxlength>\n\t\t<label for=\"id\">\n\t\t<select name><option value selected>\n\t\t<textarea rows   cols >","tags":["HTML"],"categories":["front-end"]},{"title":"WEB前端JavaScript","url":"/2018/08/30/前端JavaScript/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\nWEB前端\n<!-- more -->\n<The rest of contents | 余下全文>\n##JavaScript  简称JS\n\n\thtml搭建页面结构和内容  CSS用来美化页面  JS给页面添加动态效果或显示动态内容\n\n###JS历史\n\n\t1995年由网景（NetScape）公司发布 LiveScript 同年改名为 JavaScript，和Java没啥关系主要为了蹭热度\n###JS特点\n- 属于脚本语言 不需要编译 由浏览器解析执行\n- JS可以嵌入到Html文件中 \n- JS是基于面向对象语言\n- JS属于弱类型语言  \n###JS优点\n- 交互性： 可以直接和用户进行交互\n- 安全性： JS语言只能访问浏览器内部内容，不能访问浏览器以外内容(指磁盘中的各种数据)\n###如何在html文件中嵌入js代码\n\n\t\t<!-- 1. 在元素的事件中添加js代码 -->\n\t<input type=\"button\" value=\"点我试试\" \n\tonclick=\"alert('第一种引入方式成功！')\">\n\n\n\t<!-- 2. 通过script标签添加js代码  可以写在任意位置-->\n\t\t<script type=\"text/javascript\">\n\t\t\talert(\"第二种引入方式\");\n\t\t</script> \n\n\t<!-- 3.通过单独的*.js文件写js代码 以下方式引入 引入文件后\n\t\t不能在当前script标签体内写js代码  -->\n\t\t<script type=\"text/javascript\" src=\"first.js\">\n\t\t\t//这个位置不能再写js代码\n\t\t</script>\n\n##JavaScript语法\n###数据类型\n1. 数值类型（number）\n2. 字符串类型(string)\n3. 布尔值类型(boolean)\n4. undefined (未定义)\n5. 对象类型  null\n###变量的声明和赋值\n- 因为js属于弱类型语言 声明变量的时候不需要指定类型，直接赋值即可\n\n\tvar x = 18;\n\tvar s = \"abc\";\n\ts = 20;\n\tvar b = true/false;\n\tvar y;\n- 如果变量只声明没有赋值 则此变量的类型为undefined 值也是undefined。\n\n####数值类型 \n- 在js中所有的数值底层都是浮点型， 在使用过程中会自动转换整数或小数\n\t\tint x = 5/2; x=?(在java中结果是2)   \n\t\tvar x= 6/2; 3\n\t\tvar x = 5/2; 2.5\n- NaN（Not a Number）：不是一个数 ，用来判断一个变量是否为数值类型 判断方式通过isNaN()函数判断,当变量不是数的时候为true，是数为false\n\t\t\n\t\tisNaN(20);  false\n\t\tisNaN(\"aaa\"); true\n####字符串\n - 通过单引号或双引号修饰一个字符串，例如：var s1 = 'abc'; var s2=\"abc\";\n\n####布尔值\n- 值为true和false\n####undefined\n- 此类型只有一个值为undefined，变量声明但未定义的话为undefined\n####null\n- null为对象类型的值    var p = null; \n\n###js各种类型间的隐式转换\n1. 数值类型\n- 转字符串： 18->\"18\"     \"abc\"+18   \"abc18\"\n- 转布尔值：  0和NaN转false   其它所有数转true    \n2. 字符串\n- 转数字：  \"18\"->18   \"abc\"->NaN  \"18abc\"->18\n- 转布尔值: \"\"空字符串转成false  其它都是true\n3. 布尔值\n- 转数字： true->1   false->0\n- 转字符串：true->\"true\"    false->\"false\"    \n4. undefined\n- 转数字  NaN     21+undefined= NaN  NaN和任何数值进行运算都得NaN\n- 转布尔值  undefined->false   \n- 转字符串 undefined->\"undefined\"\n5. null\n- 转数字  null->0\n- 转布尔值    null->false \n- 转字符串 null->\"null\"    \"abc\"+null = \"abcnull\"\n\n###测试 在页面中添加两个按钮点击时 弹出 \"66\"+6  和 \"66\"-6 的结果\n\n###运算符\n- js中运算符和Java中的基本一致\n- ==和===：==会在比较两端变量数值之前先将变量类型统一，统一后再比较值.===会先比较类型是否相等如果相等再比较数值如果不等就直接false\n \"666\"==666  true     \"666\"===666  false\n\n- typeof  获取变量的类型    typeof 234234+6 = \"number6\"\n- 除法运算会自动根据结果转换整数还是小数 \n###语句\n包括：if else while do while for switch case\n- 条件如果不是布尔类型会自动转换成布尔类型\n- for 中 把int改成var， js中不支持增强for循环(foreach)\n\n\t\tfor(var i=0;i<10;i++){\n\t\t}\n###函数(方法)\n\npublic String run(String name,int age){\n\t\treturn \"abc\";\n}\n\n- 格式一：\n\t\tfunction 函数名(参数列表){\n\t\t\treturn 18;\n\t\t}\n\t例如：\n\n\t\tfunction fun(name,age){\n\t\t\treturn \"abc\";\n\t\t}\n- 格式二：\n\n\t\tvar 函数名 = function(参数列表){\n\t\t\treturn \"abc\";\n\t\t}\n####和页面元素相关的函数\n1. 得到页面元素对象的函数\n\tvar x = document.getElementById(\"id\");\n2. 获取value值或给value赋值\n\t\n\tvar z = x.value;    x.value=\"abc\";\n3. 给元素添加文本内容\n\t\n\tx.innerText=\"abc\";\t\n4. 给元素添加html代码\n\t\n\tx.innerHTML=\"<h1>abc</h1>\";\n\n### String 内容介绍\nString  数组  日期对象  正则 \n\n####字符串强转成数值\n- parseFloat: 把字符串转成整数或小数\n- parseInt:  把字符串/小数 转成整数\n- Number：等效parseFloat\n\n###String常用Api\n1. 字符串创建的方式\n\n\tvar str1 = \"abc\";\n\tvar str2 = new String(\"abc\");\n2. 转大写和转小写\n\ttoUpperCase()  toLowerCase();\n3. 查找字符串出现的位置\n\n\tstr.indexOf('a')获取a在str中第一次出现的位置\n\tstr.lastIndexOf(\"a\")获取z在str中最后一次出现的位置\n4. 截取字符串\n\tstr.substring(start,[end]);  //end可以省略 \n5. 替换字符串\n\tstr.replace(old,new);\n6. 拆分字符串\n\tstr.split(\":\") a:b:c  [a,b,c]\n\n####数值函数\n1. 四舍五入    num.toFixed(2);//参数表示保留几位小数\n\n####数组相关函数\n1. 创建数组\n\tvar arr1 = [\"刘备\",50,true];\n\tvar arr2 = new Array();//空数组\n2. 数组中添加元素\n\tarr.push(\"小明\");\n\tarr.push(18);\n3. 获取数组中的数据arr[2];\n4. 获取数组长度和修改长度 arr.length arr.length=3;\n5. 数组反转 arr.reverse();\n6. 数组排序 arr.sort();\n7. 默认排序规则：按照每一个字符的unicode编码进行排序，比较完第一个字符比较第二个，把数值当成字符串进行排序\n\n8. 自定义排序：\n\n\tvar arr = [10,5,3,25,22,29,8,18,15]; /* 使用默认排序规则排序 / //arr.sort(); //alert(arr); / 自定义规则 */ function sortfn(a,b){ //return a-b;//升序 return b-a;//降序 } arr.sort(sortfn);\n\n###日期相关函数\n1. 创建时间对象得到客户端时间\n\n\tvar d = new Date();\n\n2. 创建时间对象指定时间 var d2 = new Date(\"2018/08/02 12:38:22\");\n3. 获取和设置时间戳(距1970年1月1号 8：00:00) d2.getTime(); d2.setTime(1000);\n4. 获取时间分量\n\n    -\t/* 从完整时间年月日时分秒中提取时间分量 / \n\t-\tconsole.log(d.getFullYear());//年 \n\t-\tconsole.log(d.getMonth());//月 从0开始 需要+1 \n\t-\tconsole.log(d.getDate());//日 \n\t-\tconsole.log(d.getDay());//星期几 \n\t-\tconsole.log(d.getHours());//小时 \n\t-\tconsole.log(d.getMinutes());//分钟 \n\t-\tconsole.log(d.getSeconds());//秒\n\t-\t / 得到年月日 / \n\t-\tconsole.log(d.toLocaleDateString());\n\t-\t / 得到时分秒 */ \n\t-\t console.log(d.toLocaleTimeString());\n\n###正则表达式\n1. 场景：1. 查找内容 2. 校验文本\n2. . 匹配任意字符（除了换行）\n3. \\w 匹配任意字母、数字、下划线\n4. \\d 匹配任意数字\n5. \\s 匹配任意空白\n6. ^ 开始\n7. $ 结束\n8. 正则表达式的创建方式 var reg1 = /表达式/模式； i忽略大小写 g全局查找 var reg2 = new RegExp(\"表达式\",\"模式\")模式参数可省略 表达式\\需要转义\n9. 相关属性\n\t-   reg.exec(str); //查找内容\t查一次得到一个 没有则返回null \n\t-   reg.test(str); //校验文本\n\t-   str.match(reg);//查找内容 得到所有\n   \t-   str.replace(reg,newStr)//查找内容并替换\n\t\n\n####事件的取消\n- 在元素的事件中如果执行 return false 则取消当前事件\n\n\t\t<a href=\"http://tmooc.cn\" onclick=\"return false\">Tmooc</a>\n###失去焦点事件\n- 失去焦点以文本框为例，当光标离开的时候，此事件触发\n\t<input type=\"text\" onblur=\"\">\n###控制元素的隐藏和显示\n1. display:block/inline/inline-block/none(隐藏 脱离文档流)\n2. visibility：hidden(隐藏 不脱离文档流)/visible（显示） \n\n###自定义对象\n\n\n\t\t/* 通过声明函数的形式声明一个对象 */\n\t\tfunction Person(name,age){\n\t\t//声明属性\n\t\tthis.name=name;\n\t\tthis.age=age;\n\t\t//声明方法\n\t\tthis.run=function(){\n\t\t\talert(\"name=\"+this.name+\" age=\"+this.age);\n\t\t}\n\t\t}\n\t\t//创建对象\n\t\tvar p = new Person(\"貂蝉\",85);\n\t\tp.run();\n\t\t\n\t\t/* 声明空对象 */\n\t\tfunction SuperMan(){\n\t\t}\n\t\t//创建对象 \n\t\tvar sman = new SuperMan();\n\t\t//添加属性\n\t\tsman.name=\"克拉克\";\n\t\tsman.age=18;\n\t\t//添加方法\n\t\tsman.fly = function(){\n\t\t\talert(\"我叫\"+this.name+\"今年\"\n\t\t\t\t\t+this.age+\"岁，我在飞\");\n\t\t}\n\t\t//调用方法\n\t\tsman.fly();\n\t\n\t\t\n\t\t/* 第二种声明对象的方式 */\n\t\t/* 以声明变量的形式创建对象 */\n\t\tvar p = {\n\t\t\t\t\"name\":\"吕布\",\n\t\t\t\t\"age\":25,\n\t\t\t\t\"run\":function(){\n\t\t\t\t\talert(\"name\"+this.name+\" age=\"+this.age);\n\t\t\t\t}\n\t\t}\n\t\t//调用对象的方法\n\t\tp.run();\n\n###DHTML\n- 简介： Dynamic(动态) HTML，不是一门新技术，把HTML，CSS，JavaScript整合到一起得到的一门动态页面技术 \n- DHTML包括： BOM Browser浏览器 Object对象 Model模型 和 DOM Document文档  Object对象 Model模型 \n- BOM： 浏览器对象模型，包括一些和浏览器相关的对象和函数 \n- DOM： 文档对象模型，包括一些和页面相关的对象和函数 \n\n![](web09.png)\n###BOM的相关内容\n####window\n\twindow中所有的属性和函数，调用时可以把window省略掉，window中的属性称为全局属性，函数称为全局函数\n- window的全局函数\n\n\tparseFloat/parseInt() \n\talert();//弹出框\n\tconfirm();//确认框\n\tprompt();//弹出文本框\n\tisNaN();\n- window的全局属性\n1. location（地址）： \n\tlocation.href 可以获取和设置浏览器当前的显示地址\n\t\n\tlocation.reload()  页面刷新\n2. history（历史）：\n\thistory.length 得到当前窗口访问过的页面数量\n\thistory.forward() //访问下一个页面\n\thistory.back() // 访问上一个页面\n\thistory.go(num) 前往某个页面 0代表当前页面，1代表下个页面，2代表下两个页面 -1 代表上一个 -2 代表上两个页面\n3. screen（屏幕）：\n\twidth/height: 获取屏幕的分辨率\n\tavailWidth/availHeight：获取屏幕可用分辨率\n4. navigator（导航、帮助）\n\tnavigator.userAgent 获取浏览器的版本信息\n\n####window相关的事件\n\n1. 点击事件\n2. 加载完成事件\n3. 获取到焦点事件\n4. 失去焦点事件\n\n\t\t/* 窗口点击事件 */\n\t\t/* onclick = function(){\n\t\t\t//alert(\"窗口被点击了\");\n\t\t\tlocation.href=\"http://tmooc.cn\";\n\t\t} */\n\t\t/* 页面加载完成时执行 */\n\t\tonload = function(){\n\t\t\tvar input = document.getElementById(\"ip1\");\n\t\t\tinput.value=\"abc\";\n\t\t}\n\t\t/* 获取和失去焦点事件 */\n\t\tonblur = function(){\n\t\t\tconsole.log(\"失去焦点\");\n\t\t}\n\t\tonfocus = function(){\n\t\t\tconsole.log(\"得到焦点\");\n\t\t}\n####eval()函数\n- 可以将字符串以js代码的形式执行\n\n\n\n####通过js给元素添加css样式\n\n\tdiv.style.css样式属性名称 = \"属性的值\";\n\n###定时器\n- 通过定时器可以实现 每隔一段时间执行某些代码\n\n- var id = setInterval(函数,3000);//每隔3秒执行函数\n- clearInterval(id);//停止定时器\n- setTimeout(函数,2000);//两秒后执行函数\t\n\n###DOM\n- DOM 文档对象模型，学习dom主要掌握如果对html中的标签进行增删改查操作\n####查找元素\n- 通过id查找  document.getElementById(\"id\");\n- 通过标签名查找  document.getElementsByTagName(\"标签名\");\n- 通过元素的name属性查找 document.getElementsByName(\"name属性的值\");\n- 通过元素的class属性查找 document.getElementsByClassName(\"class属性的值\");\n- 获取body元素  document.body\n####通过层级关系查找元素\n1. 获取元素的上级元素 parentElement; \n2. 获取元素的下级内容（包括元素和文本内容和换行） childNodes\n3. 获取元素的兄弟 x.parentElement.childNodes;\n\n###创建元素\n\t\n\tvar h1 = document.createElement(\"h1\");\n\n###添加元素到某个元素里面\n\n\t父元素.appendChild(新元素);\n\n###插入元素到某个元素的上面\n\n\t父元素.insertBefore(新元素,弟弟元素);\n###删除元素\n\t父元素.removeChild(被删除的元素);\n\n\t\n###事件相关\n####事件分类\n1. 鼠标事件： onclick(点击)  onmouseover(鼠标移动到元素上面) onmouseout(鼠标移出元素)  onmousedown(在元素上鼠标按下) onmouseup(在元素上鼠标松手) onmousemove(在元素上移动)\n2. 键盘事件： onkeydown（键盘按下） onkeyup(键盘松开)\n3. 状态改变事件：onchange(value值发生改变的事件) onload（页面加载完成事件） onfocus(获得焦点事件) onblur(失去焦点事件) onsubmit(表单提交事件) onresize(窗口尺寸改变事件)\n####事件绑定\n1. 在元素标签中添加\n\t<input type=\"text\" onkeydown=\"downfn()\">\n- 此种方式添加事件 ，事件函数中的this代表的是window 如果需要用到事件对应的元素可以在标签中调用函数的时候传递过去一个this 此时的this代表元素自身\n2. 动态绑定事件\n\t/* 动态绑定事件 */\n\t\t/* mybtn.onclick = function(){\n\t\t\talert(\"动态绑定成功！\");\n\t\t}\n\t\t */\n\t\tmybtn.onclick = myfn;\n- 动态绑定的事件，事件函数中的this代表事件对应的元素\n\n####Event对象\n- 通过Event对象可以得到和事件相关的信息\n1. 可以通过event得到鼠标点击屏幕的坐标  event.clientX event.clientY\n2. 可以通过event得到键盘按键的编码 event.keyCode\n3. 通过event获得事件源 （事件源指添加事件的元素）\n\n\t/* 通过event得到事件源  存在兼容性问题 \n\t\t有的浏览器支持target 有的支持srcElement\n\t\t通过以下写法可以保证任何浏览器都能正常执行*/\n\t\tvar obj = event.target||event.srcElement;\n\t\talert(\"标签名称：\"+obj.nodeName);\n####事件传递（事件冒泡）\n- 如果同一个区域有多个事件响应，响应的顺序类似气泡，从下往上，也就是从底层元素往上级元素执行，这个过程称为事件传递\n- 如果页面中有多个元素需要添加事件，可以把事件添加在它们共同的上级元素上面，然后获得事件源，通过判断事件源来处理不同的事件\n\n\n","tags":["JavaScript"],"categories":["front-end"]},{"title":"WEB前端JQuery","url":"/2018/08/30/前端JQuery/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\nWEB前端\n<!-- more -->\n<The rest of contents | 余下全文>\n##JQuery\n####什么是JQuery\n- 是一个通过JavaScript代码写的 关于JavaScript的框架\n- 用来简化js代码\n- 可以像css一样通过选择器获取元素\n- 可以快速修改元素的样式\n\n####如何引入jQuery\n- 因为jQuery就是一个js文件 所以引入方式和引入一个普通的js文件一样\n\n\t\t<script type=\"text/javascript\" \n\t\t\tsrc=\"../js/jquery-1.4.2.min.js\"></script>\n####jQuery对象和js对象互相转换\n1. 把js转成jq\n\n\t\t/* 得到js对象 */\n\tvar input = document.getElementById(\"myinput\");\n\t/* 把js对象转成jQuery对象 */\n\t/* $是jQuery单词的缩写  $=jQuery */\n\tvar $jq = $(input);\n\t/* 弹出文本框的value值 */\n\n2. 把jq转成js\n\n\t\t/* 得到jq对象 */\n\tvar $jq = $(\"#myinput\");\n\t/* 把jq转成js对象 */\n\t//第一种写法\n\tvar js1 = $jq[0];\n\t//第二种写法\n\tvar js2 = $jq.get(0);\n\talert(js1.value+\"=\"+js2.value);\n\n###选择器\n####基础选择器\n1. 标签名选择器\n\tvar $div = $(\"div\");\t\n2. id选择器\n\tvar $div = $(\"#id\");\t\n3. 类选择器\n\tvar $div = $(\".class\");\t\n4. 分组选择器\n\tvar $div = $(\"div,#id,.class\");\t\n5. 任意元素选择器\n\tvar $div = $(\"*\");\t\n###层级选择器\n1. $(\"div span\") 匹配div下所有的span元素\n2. $(\"div>span\") 匹配div的所有span子元素\n3. $(\"div+span\") 匹配div相邻的后面的兄弟span元素 \n4. $(\"div~span\") 匹配div后面所有的兄弟span元素\n###层级函数 当得到某个元素对象后 需要获得该元素的相关元素的时候使用\n1. 获取元素的所有兄弟元素\n\t$(\"#abc\").siblings(\"div\");  \n2. 获取元素的哥哥元素\n\t$(\"#abc\").prev(\"div\");\n3. 获取元素的哥哥们元素\n\t$(\"#abc\").prevAll(\"div\");\n4. 获取元素的弟弟元素\n\t$(\"#abc\").next(\"div\"); \n5. 获取元素的弟弟们元素\n\t$(\"#abc\").nextAll(\"div\"); \n###过滤选择器\n1. $(\"div:first\")匹配所有div中的第一个  \n2. $(\"div:last\")匹配所有div中的最后一个  \n3. $(\"div:even\")匹配所有div中的偶数 从0开始\n4. $(\"div:odd\")匹配所有div中的奇数 从0开始\n5. $(\"div:eq(n)\") 匹配所有div中下标等于n的 从0开始\n6. $(\"div:lt(n)\") 匹配所有div中下标小于n的 从0开始\n7. $(\"div:gt(n)\") 匹配所有div中下标大于n的 从0开始\n8. $(\"div:not(.abc)\"  匹配所有div中class值不等于abc\n###内容选择器\n1. $(\"div:has(p)\") 匹配所有包含p标签的div\n2. $(\"div:empty\") 匹配所有空的div\n3. $(\"div:parent\")匹配所有非空的div\n4. $(\"div:contains('abc')\") 匹配包含abc文本内容的div\n###可见选择器\n1. $(\"div:hidden\") 匹配所有隐藏的div\n2. $(\"div:visible\")匹配所有可见的div\n###显示隐藏相关的函数\n1. 让隐藏的元素显示 \n\t$(\"div:hidden\").show();\n2. 让显示额元素隐藏\n\t$(\"div:visible\").hide();\n3. 切换隐藏和显示状态\n\t$(\"#abc\").toggle();\n###属性选择器\n1. $(\"div[id]\") 匹配所有有id属性的div元素\n2. $(\"div[id='abc']\") 匹配有id属性值为abc的所有div\n3. $(\"div[id!='abc']\") 匹配有id属性值不为abc的所有div\n###子元素选择器 \n1. $(\"div:nth-child(n)\") 获取div中第n个子元素 从1开始\n2. $(\"div:first-child\") 获取div中第1个子元素\n3. $(\"div:last-child\") 获取div中最后一个子元素\n###表单选择器\n1. $(\":input\") 匹配所有 文本框 密码框 单选 多选 下拉选 文本域 按钮\n2. $(\":password\") 匹配所有密码框\n3. $(\":radio\")匹配所有单选\n4. $(\":checkbox\")匹配所有多选（复选框）\n5. $(\":checked\")匹配所有被选中的 单选、多选、下拉选\n6. $(\"input:checked\") 匹配所有被选中的 单选、多选\n7. $(\":selected\") 匹配被选中的下拉选\n\n###和页面(DOM)相关\n1. 创建元素\n\tvar div = document.createElement(\"div\");\n\tvar $div = $(\"<div>abc</div>\");\n2. 添加到页面中\n\t$(\"#big\").append($div); //添加到最后面\n\t$(\"#big\").prepend($div);//添加到最前面\n\n3. 插入元素\n\t兄弟元素.after(新元素) 加载兄弟元素的后面\n\t兄弟元素.before(新元素) 加载兄弟元素的前面\n\t\t\t//添加到二哥前面 before\n\t\t\t$(\"h1:contains('二')\").before($h1);\n\t\t\t//添加到二哥的后面 after\n\t\t\t$(\"h1:contains('二')\").after($h1);\n\n4. 删除元素\n- 通过自己删除  $(\"#id\").remove();\n- 先匹配到所有的指定类型元素 从里面删除某些元素 $(\"div\").remove(\"#abc\");\n\n5. 修改元素的样式css\n\t$(\"div\").css(\"color\",\"red\");\n\n6. 属性\n\t$(\"#abc\").attr(\"id\"); 获取id的属性值 \t\n\t$(\"#abc\").attr(\"class\",\"aaa\"); 给元素添加class属性值为aaa\n\n7. 文本\n\t$(\"#abc\").text()  获取文本内容\n\t$(\"#abc\").text(\"啊啊啊\") 赋值文本内容\n8. html\n\t$(\"#abc\").html()  获取文本内容\n\t$(\"#abc\").html(\"<h1>啊啊啊</h1>\") 赋值文本内容","tags":["JQuery"],"categories":["front-end"]},{"title":"前端WEB框架","url":"/2018/08/30/前面Web框架/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\nWEB前端\n<!-- more -->\n<The rest of contents | 余下全文>\n刘国斌 77331283   bjliugb@tedu.cn\n###网站的架构\n- CS：Client Server 客户端和服务端\n\n\t移动客户端：Android和iOS\n\t电脑客户端：windows和linux、Mac OS\n\t客户端是由客户端工程师开发\n\t服务端功能：给客户端提供数据 \n\t应用场景： 京东、淘宝、唯品会\n- BS：Browser Server 浏览器和服务端\n\n\t浏览器\n\t服务端功能： 给浏览器提供数据 和 页面\n\t应用场景： 页游  \n![](web01-1.png)\n- 将来工作 BS和CS架构都会涉及，但是只需要掌握BS架构 CS就会了\n\n###课程介绍\n\n![](web01-2.png)\n###前端课程介绍\n1. HTML ： 用来勾勒出页面的结构和内容(骨架)\n2. CSS ： 用来美化页面 \n3. JavaScript： 让页面呈现动态效果和动态数据的\n4. JQuery：用来简化JavaScript代码的\n\n###HTML\n\tHyper Text Markup Language：超文本标记语言 \n- 什么是超文本：不仅仅是文本，还包括文本的字体颜色，样式 还包括多媒体（图片，音频，视频）\n- html学习内容： 学习有哪些固定的标签，还有标签内部有哪些属性和标签和标签之间的嵌套关系\n\n","tags":["WEB"],"categories":["front-end"]},{"title":"WEB前端CSS","url":"/2018/08/30/前端CSS/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\nWEB前端\n<!-- more -->\n<The rest of contents | 余下全文>\n###CSS\n- 美化页面的技术\n- Cascading 层叠 Style 样式 Sheet 表 ： 层叠样式表，CSS用于美化html页面，html可以理解成盖房子，CSS相当于装修\n\n###CSS的引入方式\n1. 内联样式：在标签内部通过 style属性添加样式，弊端：只能作用于一个元素，不能复用，几乎不使用\n\n\t\t<div style=\"color: red;border: 1px solid green;\">我是一个div</div>\n\t\t<span style=\"color: purple;border: 1px solid pink\">我是一个span</span>\n \n2. 内部样式：在head标签内部通过 style子标签添加样式，好处：可以在本页面内复用样式，弊端：不能多个页面复用同一样式 ，工作中此种方式用的不多，但是学习的时候使用内部样式，主要是方便演示\n\n\t\n\t\t<style type=\"text/css\">\n\t\t\t/* 标签名选择器 */\n\t\t\th3{\n\t\t\t\tcolor: blue;\n\t\t\t\tborder: 2px solid yellow;\n\t\t\t}\n\t\t</style>\n\n3. 外部样式：样式代码写在单独的*.css文件中，通过link标签引入到某个html页面中，好处：样式可以复用在多个页面中\n\n\t\t<link rel=\"stylesheet\" href=\"demo01.css\">\n\t\tcss文件：\n\t\t@charset \"UTF-8\";\n\n\t\tp{\n\t\t\tcolor: red;\n\t\t\tbackground-color: green;\n\t\t}\n\n###三种引入方式的优先级\n- 如果三种引入方式作用的样式不同则全部生效\n- 如果三种引入方式作用的样式相同则按照下面的优先级规则来决定到底哪个生效\n\n1. 内联优先级最高\n2. 内部和外部 后执行会覆盖先执行的\n\n###CSS的选择器\n####基础选择器\n1. 标签名选择器  \n- 应用场景：当需要对页面中所有的某一种标签设置相同效果的时候\n\t\t标签名{\n\t\t\t样式名称:值;\n\t\t\t样式名称:值;\n\t\t}\n2. id选择器\n- 通过标签的id属性找到对应的标签\n- 应用场景：当需要对页面中的某一个元素设置样式的时候使用\n\n\t\t#标签id{\n\t\t\t样式名称:值;\n\t\t\t样式名称:值;\n\t\t}\n3. 类选择器\n- 通过标签的class属性找到对应的标签\n- 应用场景：当需要对页面中的多个元素设置样式的时候使用\n\n\t\t.class{\n\t\t\t样式名称:值;\n\t\t\t样式名称:值;\n\t\t}\n####其它各种选择器\n1. 属性选择器\n- 通过标签内部指定属性查找对应的标签\n\n\t\t标签名[属性名=\"属性值\"]{\n\t\t\t样式名称:值;\n\t\t\t样式名称:值;\n\t\t}\n2. 派生选择器(后代选择器)\n- 通过多个标签之间的上下级关系查找子元素和孙子元素和。。。。所有后代元素\n\t\t\n\t\t基础选择器 基础选择器 基础选择器{\n\t\t\t样式名称:值;\n\t\t\t样式名称:值;\n\t\t}\n3. 子元素选择器\n- 通过多个标签之间的上下级关系查找子元素。\n\n\t\t基础选择器>基础选择器>基础选择器{\n\t\t\t样式名称:值;\n\t\t\t样式名称:值;\n\t\t}\n4. 分组选择器\n- 分组选择器可以把多种选择器通过逗号连接到一起，给多个选择器设置相同的样式\n\t\th3,p,.d1,#abc,#bcd{\n\t\t\tcolor:red;\n\t\t}\n\n5. 伪类选择器\n- 用于选择元素的状态\n1. visited：访问过的状态\n2. link：未点击状态\n3. hover：鼠标悬停状态\n4. active：鼠标点击时的状态\n\n- 使用方式：\n\t\t\t/* 访问过的状态 */\n\t\t\ta:visited {\n\t\t\tcolor: red;\n\t\t}\n\t\t\t/* 未点击状态 */\n\t\t\ta:link {\n\t\t\tcolor: yellow;\n\t\t}\n\t\t\t/* 鼠标悬停状态 */\n\t\t\ta:hover {\n\t\t\tcolor: blue;\n\t\t}\n\t\t\t/* 鼠标点击时的状态 */\n\t\t\ta:active {\n\t\t\tcolor: pink;\n\t\t}\n\n6. 任意元素选择器\n- 如果需要给页面中所有的元素设置相同的样式可以使用此选择器\n\n\t\t*{\n\t\t\t样式名称:值;\n\t\t\t样式名称:值;\n\t\t}\n\n\n####如果多个选择器设置相同样式的效果时，作用范围越小优先级越高\n\n###CSS中常用的属性\n- 已经接触的属性 color（字体颜色）background-color(背景颜色) border（边框）\n\n#### 元素的宽高：\n1. 块级元素的默认高度为内容高度，默认宽度为父元素的宽度\n2. 行内元素的默认宽高为内容的宽高\n- 只能修改块级元素的宽高，不能修改行内元素的宽高\n####设置元素的颜色\n\n\t\t/*1. 通过颜色名称赋值 red yellow green\n\t\t blue pink purple white black orange gray*/\n\t\t/*2. 6位16进制赋值 每两位表示一个颜色 红 绿 蓝   */\n\t\t/* background-color: #ff00ff; */\n\t\t/*3. 3位16进制赋值 每一位表示一个颜色  */\n\t\t/* background-color: #00f; */\n\t\t/*4. 通过3位 10进制赋值 每个取值0-255  */\n\t\t/* background-color:rgb(255,255,0); */\n\t\t/*5. 4位10进制赋值 第四位代表透明度取值0-1 */\n\t\tbackground-color: rgba(0,255,0,0.5);\n####设置元素的背景图片\n\n\t\t/* 设置背景图片 */\n\t\tbackground-image: url(\"../imgs/a.jpg\");\n\t\t/* 设置背景图片的大小 参数为宽和高  */ \n\t\tbackground-size: 100px 100px;\n\t\t/* 设置背景图片不重复 */\n\t\tbackground-repeat: no-repeat;\n\t\t/* 设置背景图片的位置 left center right top bottom \n\t\t第一个参数代表水平 第二个参数代表垂直*/\n\t\t/* background-position: right center; */\n\t\t/* 通过百分比控制位置 */\n\t\tbackground-position:90% 90%;\n\n\n\n###盒子模型\n####外边距\n- 元素距离父元素或相邻兄弟元素的距离称为外边距\n- 赋值方式：\n\n\t\t/* margin: 40px; 四个外边距都是40px */\n\t\t/* margin: 20px 50px; 上下20 左右50 */\n\t\t/* margin: 0 auto; 水平居中 */\n\t\tmargin: 10px 30px 60px 90px;/* 顺时针 上右下左 */\n- 块级元素：上下左右都生效\n- 行内元素：只有左右生效 上下不生效\n- 外边距粘连问题： 当元素的上边缘和父元素的上边缘重合的时候，子元素的上外边距会带着父元素一起移动，通过在父元素中添加 overflow:hidden;解决。\n- 上下外边距取最大值，左右外边距相加\n####边框\n\tborder: 粗细(像素值) 边框的样式(solid) 颜色\n\t/* border: 10px inset purple; */\n\t\tborder-bottom:5px solid yellow;\n\t\tborder-left:5px solid pink;\n\t\tborder-top:5px solid green;\n\t\tborder-right:5px solid black;\n\t\tborder-radius:55px;/*圆角 值越大越园  */\n- 块级元素： 上下左右边框全部生效，而且边框都会占显示区域\n- 行内元素： 上下左右边框全部生效，但是只有左右边框才会占显示区域，上下不占显示区域（不会增加元素自身的高度）\n\n####内边距\n- 内容距离边框的距离\t\n- 给元素添加内边距会影响元素的宽高\n- 移动元素内的子元素几种方式？ 两种：1. 给大的添加内边距（大的所占宽高会跟着改变） 2. 给小的添加外边距\n- 移动元素内的文本的时候几种？ 一种：只能给大的添加内边距。\n- 块级元素：内边距四个方向都生效，而且都会影响元素的显示范围\n- 行内元素：内边距四个方向都生效，左右影响显示范围，上下不影响显示范围\n\n####块级元素和行内元素关于盒子模型的总结\n1. 块级元素：可以设置宽高，外边距全部生效 并且影响元素的所占宽高, 边框四个方向都生效，并且影响元素的所占宽高，内边距全部生效，并且影响元素所占的宽高\n2. 行内元素：不可以设置宽高，外边距左右生效，上下不生效，边框都生效，上下不影响所占高度，内边距都有效果，左右影响所占宽度 上下不影响所占高度\n###元素所占宽度计算公式\n宽高为100*200 左外边距10 右外30  边框5px 左内8px 右内2px\n\n100+10+30+5*2+8+2\n左外边距+左边框+左内边距+元素宽度+右内边距+右边框+右外边距\n\n###文本相关的属性\n\n\t\t/* 文本相关属性 */\n\t\t/* 文本水平对齐方式 center/left/right */\n\t\ttext-align: center;\n\t\t/* 文本修饰  none 没有 \n\t\tunderline 下划线\n\t\toverline 上划线\n\t\tline-through 删除线*/\n\t\ttext-decoration: line-through;\n\t\t/* 文本颜色 */\n\t\tcolor: red;\n\t\t/* 行高  通常让文本垂直居中的时候使用行高 */ \n\t\tline-height: 100px;\n\t\t/* 文本阴影   4个参数\n\t\t1. 阴影颜色 \n\t\t2和3是阴影的偏移值  \n\t\t4. 阴影的模糊度 值越小越清晰 0是不模糊*/\n\t\ttext-shadow: #0f0 -15px 15px 1px;\n\n####字体相关属性\n\n\t\t/* 字体相关属性 */\n\t\tfont-size: 20px;\n\t\t/* 字体粗细属性  normal 不加粗\n\t\t\tbold 加粗\n\t\t\tlighter 比普通细一些\n\t\t */\n\t\tfont-weight: lighter;\n\t\t/* 字体样式  可以设置多个值通过逗号分隔，以此检测\n\t\t哪个生效用哪个 */\n\t\tfont-family: \"楷体\";\n\t\t/* 设置斜体 */\n\t\tfont-style: italic;\n\n###溢出设置 \n- 指子元素显示范围超出父元素范围时的设置\n\n\t\t/* visible(默认 超出显示)\n\t\thidden: 超出不显示\n\t\tscroll:超出滚动显示  */\n\t\toverflow: hidden;\n###元素显示方式\n- block： 块级元素默认的显示方式，独占一行，可以修改宽高\n- inline：行内元素的默认显示方式，共占一行，不可以修改宽高\n- inline-block:行内块，共占一行 并且可以修改宽高\n\n###元素的定位\n####position定位\n#####静态定位（文档流定位）（默认）\n- 元素如果是块级元素则默认从上到下排列，如果是行内元素则从左向右排列\n- 设置方式： position:static;\n#####相对定位\n- 相对于元素初始的位置，通过left/right/top/bottom让元素做位置的偏移\n- 元素不会脱离文档流\n- 场景：当元素需要从当前位置做位置偏移的时候，并且不希望其它元素跟着移动时使用此定位\n#####绝对定位\n- 会脱离文档流 后面有元素的话会顶上来\n- left/right/top/bottom 做位置偏移，相对于谁？ 1. 相对于窗口(没有祖宗或有祖宗但是没有做非static定位) 2. 相对于祖宗元素(有祖宗并且有某个祖宗做了非static定位，如果都做了，则就近原则)（如果仅仅是为了给子元素做位置的参考一般都使用relative）\n- 场景：当元素需要相对于某个祖先元素或窗口做位置偏移的时候，并且不再占用原来的位置时使用此定位方式\n#####固定定位\n- 固定在窗口的某个位置，不会随着内容位置改变而改变\n- 脱离文档流，left/right/top/bottom 坐标相对于窗口\n####浮动定位\n- 元素脱离文档流，元素在当前所在行内 左侧或右侧浮动，当撞到父元素边框或浮起来的兄弟元素边缘的时候\n- 如果所有浮动的元素一行装不下会自动换行，但是如果有凸出的元素会有卡住的效果\n- 如果元素浮动则后面的元素会往上顶(因为浮动会脱离文档流)，如果不希望后面的元素往上移动，则需要在后面紧邻的元素上添加clear属性设置both/left/right,禁止元素 两边/左/右 有浮动的元素。\n- 如果元素的所有子元素全部浮动，并且元素没有设置高度，此时自动识别的高度为0，可以通过添加 overflow:hidden; 让元素能够识别出浮动后子元素的高度\n- 应用场景：当多个纵向排列的元素需要改成横向排列的时候 使用浮动定位\n- 练习： demo08.html 页面中添加一个无序列表把列表项改成横向排列\n####行内元素的垂直对齐方式\n- 默认对齐方式为基线对齐 vertical-align：baseline\n- top/middle/bottom\n\n###CSS的三大特性\n1. 继承性：子元素可以继承父元素的部分属性，只能继承color/font-开头/text-文本相关/line- 此类型的属性，不仅仅子元素继承所有的后代元素都会继承\n- 如果元素自身所带的样式和继承的冲突则以自身所带样式为准，如：h标签的字体大小，超链接的文本颜色和文本下划线\n2. 层叠性：通过不同的选择器可以多次指向同一个元素，如果设置的样式不同则全部生效，如果多个选择器设置的样式相同，则根据CSS的第三特性优先级来决定\n3. 优先级：\n- 直接选中优先级高于间接选中(继承属于间接选中)\n- 如果相同选择器，则后执行的覆盖前面的\n- 不同选择器，作用范围越小 优先级越高    id>class>标签名>继承\n###CSS定位\n####Position\n- position：static，静态定位（文档流定位）， 从上到下 从左向右\n- relative，相对定位：不脱离文档流，上右下左相对于元素初始位置\n- absolute，绝对定位：脱离文档流，相对于窗口或祖先元素\n- fixed，固定定位：脱离文档流，相对于窗口，固定在窗口的某个位置\n####浮动定位\nfloat:left/right; 元素会在当前所在行内左侧或右侧浮动\n- 脱离文档流\n- 如果后面的元素不想顶上去 添加 clear:left/right/both\n- 如果元素所有子元素全部浮动的话 内容高度识别为0 通过添加overflow：hidden解决","tags":["CSS"],"categories":["front-end"]},{"title":"Java面向对象-雷霆战机","url":"/2018/07/23/Java面向对象雷霆战机/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n<The rest of contents | 余下全文>\n\n雷霆战机搭建过程","tags":["雷霆战机\\小游戏"],"categories":["after-end"]},{"title":"环境搭建(附链接)","url":"/2018/06/23/环境搭建连接详细版/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n<The rest of contents | 余下全文>\n第一步：搭建环境。\n\n\t安装新建虚拟机CentOS。环境搭建好之后。\n\n第二步：安装jdk（我使用的第一种方法）\n\n*[linux系统下安装jdk](https://blog.csdn.net/qciwyy/article/details/77449369)\n\n\n第三步：安装mysql服务器（我使用的方法2）\n\n*[linux系统安装mysql-server](https://blog.csdn.net/qciwyy/article/details/77526895)\n\n第四步：修改mysql-server登陆密码\n\n*[修改mysql root密码](https://blog.csdn.net/qciwyy/article/details/77529153)\n\n第五步：mysql创建用户并授予远程访问权限\n\n*[linux系统给mysql创建新用户并授予远程访问权限](https://blog.csdn.net/qciwyy/article/details/77643595)\n\n第六步：mysql表明区分大小写转换为不区分大小写（这样为了避免在设计表的时候有大写和小写出现异常）\n\n*[linux下mysql表名不区分大小写](https://blog.csdn.net/qciwyy/article/details/77648715)\n\n第七步：MySQL数据库从Windows迁移到linux\n\n*[MySQL数据库从Windows迁移到linux](https://blog.csdn.net/QCIWYY/article/details/77567154)\n\n第八步：CentOS中安装与配置Tomcat\n\n*[linux系统安装tomcat](https://blog.csdn.net/qciwyy/article/details/77645638)\n\n第九步：Tomcat安装成功后， 将需要部署的java web项目复制到/usr/local/tomcat/webapps下，重新起到tomcat服务\n\n\t浏览器输入：localhost:8080/HelloWorld  成功访问。\n\n\n","tags":["JDK Tomcat MySql"],"categories":["servicer"]},{"title":"Java面向对象","url":"/2018/06/23/Java面向对象/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n<The rest of contents | 余下全文>\n\n面向对象","tags":["OOP"],"categories":["after-end"]},{"title":"环境搭建Centos7.4","url":"/2018/06/23/环境搭建centos7.4/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n<The rest of contents | 余下全文>\n>##安装jdk\n\n1. 下载jdk\n\n\t\twget http://download.oracle.com/otn-pub/java/jdk/8u181-b13/96a7b8442fe848ef90c96a2fad6ed6d1/jdk-8u181-linux-x64.rpm?AuthParam=1536633909_fcc6805cd13d0e7e32ce7e7b69ce0620\n2.将文件放至/usr/local\n\t\n\t\t scp /Users/leelom/Downloads/jdk-7u79-linux-x64.rpm root@123.xxx.xx.xx:/usr/local\n\n2. 安装jdk\n\n\t\trpm -ivh jdk-8u181-linux-x64.rpm\n3. 查询java版本号\n  \n\t     此处出现版本号 jdk1.8.0_181 \n4.修改配置\n\t\n\t\t vi /etc/profile\n5. 复制以下内容\n\n文件名不同 复制内容不同\n\n\t\tJAVA_HOME=/usr/java/jdk1.8.0_181-amd64\n\t\tJRE_HOME=/usr/java/jdk1.8.0_181-amd64/jre\n\t\tPATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin\n\t\tCLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib\n\t\texport JAVA_HOME JRE_HOME PATH CLASSPATH\n\n\t###添加以下文档 \n\n\t\tJAVA_HOME=/usr/java/jdk1.8.0_181 \n\t\tJRE_HOME=/usr/java/jdk1.8.0_181/jre \n\t\tPATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin \n\t\tCLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib \n\t\texport JAVA_HOME JRE_HOME PATH CLASSPATH\n\n>##安装Tomcat\n此处为tomcat9版本\n\n1.下载tomcat\n\t\n\t wget http://mirrors.sonic.net/apache/tomcat/tomcat-9/v9.0.11/bin/apache-tomcat-9.0.11.tar.gz\n2. 解压压缩包\n\t\t\n\ttar -zxf apache-tomcat-9.0.11.tar.gz \n3.删除压缩包\n\n\t rm -rf apache-tomcat-9.0.11.tar.gz  \n4.文件移动\n\n\t mv  apache-tomcat-9.0.11 tomcat \n5. 启动tomcat\n\t\n\t\t [root@admin ~]# /usr/local/tomcat/bin/startup.sh //启动tomcat  \n\t\tUsing CATALINA_BASE: /usr/local/tomcat  \n\t\tUsing CATALINA_HOME: /usr/local/tomcat  \n\t\tUsing CATALINA_TMPDIR: /usr/local/tomcat/temp  \n\t\tUsing JRE_HOME: /usr/java/jdk1.7.0/jre  \n\t\tUsing CLASSPATH: /usr/local/tomcat/bin/bootstrap.jar:/usr/local/tomcat/bin/tomcat-juli.jar \n6. 浏览器  http://ip:8080  验证\n7. 修改配置 tomcat server.xml\n\t* [server.xml](http://blog.csdn.net/jimmy609/article/details/37766069)\n\n\n>##安装MySQL\n\n* [CentOS 7.4下使用yum安装MySQL5.7.20 最简单的](https://blog.csdn.net/z13615480737/article/details/78906598)","tags":["Centos7.4   Jdk8  Tomcat9  Mysql5.7.20"],"categories":["servicer"]},{"title":"Java基础","url":"/2018/06/23/Java基础Basic/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n<The rest of contents | 余下全文>\n> **Java开发环境:**\n\n*1)java编译运行过程:-------------常见面试题*\n\n\t    1.1)编译期:.java源文件，经过编译，生成.class字节码文件\n\t    1.2)运行期:JVM加载.class并运行.class\n    \t\t特点:跨平台、一次编程到处使用\n  *2)名词解释:-------------常见面试题*\n\n    2.1)JVM:java虚拟机\n            加载.class并运行.class\n    2.2)JRE:java运行环境\n            除了包含JVM以外还包含了运行java程序所必须的环境\n\t    JRE=JVM+java系统类库(小零件)\n    2.3)JDK:java开发工具包\n            除了包含JRE以外还包含了开发java程序所必须的命令工具\n\t    JDK=JRE+编译、运行等命令工具\n    说明:\n      2.1)运行java程序的最小环境为JRE\n      2.2)开发java程序的最小环境为JDK\n  *3)配置环境变量---------------了解*\n\n    3.1)JAVA_HOME:指向jdk的安装路径\n    3.2)CLASSPATH:表示类的搜索路径(一般简写为.)\n    3.3)PATH:指向jdk下的bin目录\n\n> **eclipse:**\n\n\t  1)IBM、开源的、免费的、不需要安装仅需解压即可\n\t  2)开发步骤:\n\t    2.1)新建Java项目/工程---------------小区\n\t    2.2)新建Java包----------------------楼+单元\n\t    2.3)新建Java类----------------------房子\n\t          main中:\n\t\t    System.out.println(\"HelloWorld\");\n\t  3)注释:解释性文字\n\t    3.1)单行注释://\n\t    3.2)多行注释:/* */\n\t    3.3)文档注释:/** */\n\n>**变量:存数的，代词，指代的就是它所存的那个数**\n\t\n\t  1)声明:\n\t      int a; //声明一个整型的变量，名为a\n\t      int b,c,d; //声明三个整型的变量，名为b,c,d\n\t  2)初始化:第一次赋值\n\t    2.1)声明的同时初始化:\n\t          int a = 250; //声明整型变量a并赋值为250\n\t    2.2)先声明后初始化:\n\t          int a;   //声明整型变量a\n\t\t \t  a = 250; //给变量a赋值为250\n\t  3)使用:\n\t    3.1)对变量的使用就是对它所存的那个数的使用\n\t          int a = 5;\n\t\t\t  int b = a+10; //取出a的值5，加10后，再赋值给整型变量b\n\t\t\t  System.out.println(b);   //输出变量b的值15\n\t\t\t  System.out.println(\"b\"); //输出b，双引号中的原样输出\n\t\t\t  a = a+10; //取出a的值5，加10后，再赋值给a\n\t\t\t            //在a本身基础之上增10\n\t\t\t  System.out.println(a); //15\n\t    3.2)变量在使用时必须类型匹配\n\t          int a = 3.14; //编译错误，数据类型不匹配\n\t    3.3)变量在用之前必须声明并初始化\n\t          System.out.println(m); //编译错误，m未声明\n\t\t \t  int m;\n\t\t \t  System.out.println(m); //编译错误，m未初始化\n\t  4)命名:\n\t    4.1)只能包含字母、数字、_和$符，并且不能以数字开头\n\t    4.2)严格区分大小写\n\t    4.3)不能使用关键字\n\t    4.4)可以中文命名，但不建议\n\t        建议\"英文的见名知意\"、\"驼峰命名法\"\n>**基本数据类型:共8种**\n\n\t  1)int:整型，4个字节，-21个多亿到21个多亿\n\t\t    1.1)整数直接量默认为int型，但不能超范围，超范围则编译错误\n\t\t    1.2)两个整数相除，结果还是整数，小数位无条件舍弃(不会四舍五入)\n\t\t    1.3)运算时超范围，则发生溢出，溢出是需要避免的\n\t  2)long:长整型，8个字节，很大很大很大\n\t\t    2.1)表示长整型直接量，需在数字后加L或l\n\t\t    2.2)运算时若有可能溢出，建议在第1个数字后加L\n\t\t    2.3)System.currentTimeMillis()用于获取自\n\t\t        1970.1.1零时到此时此刻的毫秒数\n\t  3)double:浮点型，8个字节，\n\t\t    3.1)浮点数直接量默认为double型，若想表示float需在数字后加f或F\n\t\t    3.2)double和float在运算时，有可能会出现舍入误差(精确运算场合不能使用)\n\t  4)boolean:布尔型，1个字节\n\t  \t    4.1)只能取值为true和false\n\t  5)char:字符型，2个字节\n\t\t    5.1)采用Unicode字符集编码，一个字符对应一个码(0到65535之间)\n\t\t        表现的形式的字符char，但本质上是码int\n\t\t\tASCII码('a'--97  'A'--65  '0'--48)\n\t\t    5.2)字符直接量必须放在单引号中，只能有一个\n\t\t    5.3)特殊符号需通过\\来转义\n>**基本数据类型间的转换:**\n\n    数据类型从小到大依次为:\n      byte,short,int,long,float,double,char,\n\n\t  1)两种方式:\n\t    1.1)自动类型转换:小类型到大类型\n\t    1.2)强制类型转换:大类型到小类型\n\t          eg: (要转换成为的数据类型)变量\n\t\t  强转有可能溢出或丢失精度\n\t  2)两点规则:\n\t    2.1)整数直接量可以直接赋值给byte,short,char，但不能超出范围\n\t    2.2)byte,short,char型数据参与运算时，先一律转换为int再运算\n>**Scanner接收用户的输入:**\n\n\t  1)在package下:\n\t      import java.util.Scanner;\n\t  2)在main()中:\n\t      Scanner scan = new Scanner(System.in);\n\t  3)在第2步之下:\n\t      System.out.println(\"请输入年龄:\");\n\t      int age = scan.nextInt();\n\t      System.out.println(\"请输入价格:\");\n\t      double price = scan.nextDouble();\n>**运算符:**\n\t\n\t  1)算术运算符:+,-,*,/,%,++,--\n\t  2)关系运算符:>,<,>=,<=,==,!= boolean\n\t  3)逻辑运算符:&&,||,! boolean\n\t  4)赋值运算符:=,+=,-=,*=,/=,%=\n\t  5)字符串连接运算符:+\n\t  6)条件/三目运算符:boolean?数1:数2\n>**分支结构:**\n\n\t  1)if结构:1条路\n\t  2)if...else结构:2条路\n\t  3)if...else if结构:多条路\n\t  4)switch...case结构:多条路\n\t    优点:效率高、结构清晰\n\t    缺点:整数、相等\n\t    break:跳出switch\n>**循环:**\n\n\t反复执行一段相同或相似的代码\n\n>**循环三要素:**\n\n\t  1)循环变量的初始化\n\t  2)循环的条件(以循环变量为基础)\n\t  3)循环变量的改变(向着循环的结束变)\n\t  循环变量:在整个循环过程中所反复改变的那个数\n>**循环结构:**\n\n\t  1)while结构:先判断后执行，有可能一次都不执行\n\t  2)do...while结构:先执行后判断，至少执行一次\n\t                   要素1与要素3相同时，首选do...while\n\t  3)for结构:应用率最高，固定次数循环\n\n>**break:跳出循环**\n\n \t continue:跳过循环体中剩余语句而进入下一次循环\n>**三种循环结构的更佳适用情况:**\n\n\t  1)while:\"当...\"\n\t          要素1与要素3不同时首选while\n\t  2)do...while:\"直到...\"\n\t          要素1与要素3相同时首选do...while\n\t  3)for:固定次数循环，应用率最高\n>**嵌套循环:**\n\n\t  1)循环中套循环，一般多行多列时使用，外层控制行，内层控制列\n\t  2)执行规则:外层循环走一次，内层循环走所有次\n\t  3)建议:嵌套层数越少越好，能用一层就不用两层，能用两层就不用三层\n\t    若需求必须要使用三层以上的循环才能解决，说明设计有问题\n\t  4)break只能跳出一层循环\n>**程序=算法+数据结构------------了解**\n\n\t  1)算法:解决问题的流程/步骤(顺序、分支、循环)\n\t  2)数据结构:将数据按照某种特定的结构来保存\n\t             数怎么存\n\t    设计良好的/合理的数据结构会导致好的算法\n>**数组:**\n\t\n\t  1)是一种数据类型(引用类型)\n\t  2)相同数据类型元素的集合\n\t  3)数组的定义:\n\t      int[] arr = new int[10];\n\t  4)数组的初始化:\n\t\t      int[] arr = new int[3]; //0,0,0\n\t\t      int[] arr = {2,5,8}; //2,5,8\n\t\t      int[] arr = new int[]{2,5,8}; //2,5,8\n\t\t      int[] arr;\n\t\t      arr = {2,5,8}; //编译错误，此方式只能声明同时初始化\n\t      \t  arr = new int[]{2,5,8}; //正确\n\t  5)数组的访问:\n\t    5.1)通过数组名.length可以获取数组的长度(元素的个数)\n\t          int[] arr = new int[10];\n\t\t  \t  System.out.println(arr.length); //10\n\t    5.2)通过数组的下标/索引来访问元素\n\t        下标从0开始，最大到(数组的长度-1)\n\t\t\t  int[] arr = new int[3];\n\t\t\t  arr[0] = 100; //给arr中第1个元素赋值为100\n\t\t\t  arr[1] = 200; //给arr中第2个元素赋值为200\n\t\t\t  arr[2] = 300; //给arr中第3个元素赋值为300\n\t\t\t  arr[3] = 400; //数组下标越界异常\n\t\t\t  System.out.println(arr[arr.length-1]); //输出最后一个元素的值\n\t  6)数组的遍历:\n\t\t      int[] arr = new int[10];\n\t\t      for(int i=0;i<arr.length;i++){\n\t\t        arr[i] = 100;\n\t\t      }\n\t\t      for(int i=0;i<arr.length;i++){\n\t\t        System.out.println(arr[i]);\n\t\t      }\n\t\t      for(int i=arr.length-1;i>=0;i--){\n\t\t        System.out.println(arr[i]);\n\t\t      }\n\t  7)数组的复制:\n\t\t    7.1)System.arraycopy(a,1,a1,0,4); //效率高、灵活性好\n\t\t    7.2)int[] a1 = Arrays.copyOf(a,6); //效率低、灵活性差\n\t\t        a = Arrays.copyOf(a,a.length+1); //数组的扩容/缩容\n\t  8)数组的排序:\n\t\t    8.1)Arrays.sort(arr); //升序，效率高\n\t\t    8.2)冒泡排序:----车轮战\n\t\t        8.2.1)四个数冒三轮\n\t\t\t8.2.2)每一轮都是从第1个元素开始冒\n\t\t\t      每一次都是和它的下一个元素比\n\t\t\t8.2.3)冒出来的就不再参与比较了\n>**方法:**\n\t\n\t  1)封装一段特定的业务逻辑功能\n\t  2)尽可能独立，一个方法只干一件事\n\t  3)可以被反复多次调用\n\t  4)减少代码的重复，有利于代码的维护，有利于团队的协作\n>**方法的定义:**\n\n\t    修饰词 返回值类型 方法名(参数列表){ //形参\n\t      方法体\n\t    }\n>**方法的调用:**\n\n\t  1)无返回值: 方法名(有参传参); //实参\n\t  2)有返回值: 数据类型 变量 = 方法名(有参传参);\n>**return:**\n\n\t  1)return 值; //1.1)结束方法的执行 1.2)返回结果给调用方\n\t  2)return;    //2.1)结束方法的执行(在某种条件之下提前结束方法)\n","tags":["基础"],"categories":["after-end"]},{"title":"Spring框架部分","url":"/2018/06/23/面试题Spring框架/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n<The rest of contents | 余下全文>\n\n一、\t你用过spring框架吗？\n\n\ta)\t用过，spring框架是轻量级，代码侵入性低,可集成，用来简化web开发的应用开发的框架。 \n二、\tSpring容器是什么？\n\n\ta)\t是Spring框架当中的一个核心模块，用于对对象进行管理。\n三、\t什么是IOC什么是DI？DI如何实现的？\n\n\ta)\tIOC叫控制反转，是Inversion of Control 的缩写。\n\t所谓的“控制反转”就是对组件对象控制权的转移，从程序代码本身转移到了外部容器，由容器来创建对象并管理对象之间的依赖关系。\n\tb)\tDI 叫依赖注入，是Dependency Control的缩写，是对IOC更简单的诠释。\n四、\tSpring中的Bean的作用域有哪些？\n\n\ta)\t两个作用域\n\t\t1.\tSingleton: 表示Bean以单例的形式存在。一般情况下，无状态或状态不可变的类适合单例模式。\n\t\t2.\tPrototype:\t表示每次从容器中调用Bean时，都会返回一个新的实例。\n五、\t请你阐述下SpringMVC分为几大组件？SpringMVC的执行流程（也就是这五大组件的关系）\n\n\ta)\t五大组件：\n\t\t1.\tdispatcherServlet\t (前端控制器)\n\t\t2.\thandlerMapping\t\t（前端控制器秘书）\n\t\t3.\tcontroller\t\t\t（处理器）\n\t\t4.\tViewResolver\t\t（视图解析器）\n\t\t5.\tModelAndView\t\t（模型和视图）\n\tb)\tdispatcherServlet前段控制器收到请求之后，依据HandlerMapping的配置调用相应的Controller来处理\n\tcontroller将处理结果封装成ModeAndView发送给前段控制器DispatcherServlet\n\tdispatcherServlet前端控制器会依据ViewResolver的配置调用相应的配置，调用相应的视图对象（比如JSP）\n\t来展现数据\n六、\t你了解Java反射机制吗？Java中哪些地方用到了反射？\n\n\ta)\t就是在运动状态中，对于任意一个类，都能够知道这个类的所有属性和方法，对于任意一个对象，\n\t都能够调用它的任意一个方法和属性；这种动态获取信息以及动态调用对象的方法的功能称为反射。\n\tb)\tSpring框架底层就是通过反射实现的。\n七、\t什么是MyBatis框架？\n\n\ta)\t作用就是封装了JDBC,简化了数据库的访问代码。\n八、\tMyBatis中的Mapper映射器要满足那些要求？\n\n\ta)\tMapper.xml的\n\t\t1.\tNamespace\t\t== \t接口名\n\t\t2.\tsql语句id\t\t==\t方法名\n\t\t3.\tparameterType\t==  方法参数类型\n\t\t4.\tresultType\t\t==\t返回值类型\n九、\t解释一下什么叫AOP Aspect Oriented Programming（面向切面编程）？\n\t\n\ta)\tAOP可以对业务逻辑的各个部分进行隔离，也就是可以降低业务逻辑各部分的耦合度，提高程序的可重用性，提高开发效率。\n\tb)\t主要的功能有5点（或更多）：\n\t\t1.\t日志记录\n\t\t2.\t性能统计\n\t\t3.\t安全控制\n\t\t4.\t事务处理\n\t\t5.\t异常处理\n十、\tAOP和OOP有什么区别？\n\n\ta)\tAOP、OOP在字面上虽然非常类似，但却是面向不同领域的两种设计思想。\n\tb)\tOOP（面向对象编程）针对业务处理过程的实体及其属性和行为进行抽象封装，以获得更加清晰高效的逻辑单元划分。\n\tc)\t而AOP则是针对业务处理过程中的切面进行提取，它所面对的是处理过程中的某个步骤或阶段，以获得逻辑过程中各部分之间低耦合性的隔离效果。\n\td)\t总之，AOP可以通过预编译方式和运行期动态代理实现在不修改源代码的情况下给程序动态统一添加功能的一种技术。\n十一、\t什么是AJAX?\n\n\ta)\tajax是一种用来改善用户体验的技术，也就是局部刷新，其本质是利用浏览器内部的一个对象(XMLHttpRequest)异步的向服务器发送请求。\n十二、\tajax对象的几个重要的属性？\n\t\n\ta)\t5个\n\t\t1.\tOnreadystatechange:\t\t用来绑定事件处理函数的\n\t\t2.\tReadystate：\t\t\t有5个值（0,1,2,3,4）表示对ajax对象与服务通信的状态（进展）\n\t\t3.\tresponseText：\t\t\t获得服务器返回的文本\n\t\t4.\tresponseXML：\t\t\t获得服务器返回的xml文档\n\t\t5.\tstatus：\t\t\t\t获得服务器返回的状态码（200/202/400/404/500）\n十三、\tAJAX都有哪些优点和缺点\n\n\t优点:\n\t1.\t最大的一点是页面无刷新，用户的体验非常好。\n\t2.\t使用异步方式与服务器通信，具有更加迅速的响应能力。\n\t3.\t可以把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理，减轻服务器和带宽的负担，节约空间和宽带租用成本。并且减轻服务器的负担，ajax的原则是“按需取数据”，可以最大程度的减少冗余请求，和响应对服务器造成的负担。\n\t4.\t基于标准化的并被广泛支持的技术，不需要下载插件或者小程序。\n\tajax的缺点:\n\t6.\tajax不支持浏览器back按钮。\n\t7.\t安全问题 AJAX暴露了与服务器交互的细节。\n\t8.\t对搜索引擎的支持比较弱。\n\t9.\t破坏了程序的异常机制。\n\t10.\t不容易调试\n十四、\tJSON是什么？语法是怎么样的？\n\t\n\ta)\t是一种轻量级的数据交换模式，比xml要小，解析速度更加快。\n\tb)\t使用JSON表示一个对象{“属性名”：属性值，“属性名”：属性值};\n十五、\t面向对象和面向过程有什么区别？\n\n\ta)\t面向过程是一种以过程为中心的编程思想。就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步的实现，使用的时候一个一个依次调用就可以了。注重的是过程。\n\tb)\t面向对象是一种以事务为中心的编程思想。面向对象的方法主要是把事务给对象化，对象包括属性和行为，忽略某些细节，注重的是结果。\n\tc)\t比如我想去厦门，面向过程是我开什么车去，怎么开，之间的过程是什么，都要很详细。面向对象是我要去厦门，到厦门即可，不管你是怎么到的。\n十六、\tOracle和Mysql有什么区别？\n\n\ta)\t库函数不同\n\tb)\tOracle是用表空间来管理的，Mysql不是\n\tc)\t分页查询的时候mysql是用limt   oracle用rownum\n\td)\tSql的语法不同\n\n\n\n\n\n","tags":["面试资料"],"categories":["interview"]},{"title":"Html部分","url":"/2018/06/23/面试题Html/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n<The rest of contents | 余下全文>\n一、\t索引有几种类型？\n\n\ta)\t4种类型：\n\t\t1.\t唯一索引：\t\t不允许其中任何两行具有相同索引值得索引。\n\t\t2.\t非唯一索引：\n\t\t1.\t主键索引：\t\t数据库表经常有一列或者多列组合，其值唯一标识表中的每一行。该列称为表的主键。在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。\n\t\t3.\t聚集索引：\t\t在聚集索中，表中行的物理顺序与键值得逻辑（索引）顺序相同。一个表只能包含一个聚集索引\n二、\tCSS选择器包括哪些？\n\t\n\ta)\t类选择器：\t\t用“.”来标识\n\tb)\t标签选择器：\t用“HTML”标签来标识\n\tc)\tID选择器：\t\t用“#”号来标识\n三、\tJavaScript包括哪些数据类型？\n\t\n\ta)\t6种数据类型\n\t1.\tUndefined   原始数据类型\n\t2.\tNull\t\t原始数据类型\n\t3.\tString\t\t原始数据类型\n\t4.\tNumber\t\t原始数据类型\n\t5.\tBoolean\t\t原始数据类型\n\t6.\tObject\t\t对象数据类型\n四、\tServlet生命周期？\n\t\n\ta)\t（Web容器）服务器启动并加载Servlet后，Servlet生命周期开始，容器运行init方法，请求到达时运行其service方法，\n\t请求到达，service方法自动派遣运行与请求对应的doGet或doPost方法，当服务器决定将实例销毁的时候调用其destroy方法。\n五、\t什么是Servlet？\n\n\ta)\tServlet就是处理服务器与客户端交互的一个组件，主要用于响应HTTP请求，一般在MVC中的C(controller)控制层\n六、\tB/S和C/S的区别？\n\t\n\ta)\tB/S是浏览器与服务器\t\t不安全\t\t维护成本低\t 一般用于广域网  \n\tb)\tC/S是客户端与服务器\t\t安全\t\t维护成本高   一般用于局域网\n七、\tMVC各个部分都有哪些技术来实现？\n\t\n\ta)\tM是model简写 也就是业务逻辑层（通过javaBean，EJB组件实现）\n\tb)\tV是View简写，也就是应用的表面层（由jsp页面产生）\n\tc)\tC是controller简写，也就是提供应用的处理过程控制（一般是一个Servlet），\n\td)\t通过这种设计模式把应用逻辑，处理过程，和显示逻辑分成不同的组件，这些组件可以交互和重用。\n八、\tServlet如何获取表单的参数？\n\t\n\ta)\t通过request.getParamenter();\n\t九、\tJSP和Servlet的异同？他们之间的联系是什么？\n\ta)\tJSP本质上就是Servlet技术的拓展，也就是简易版的servlet。\n\tb)\tJSP更加强调应用的外表表达，侧重于视图，Servlet更加注重于控制逻辑。\n\tc)\tJSP编译后是类Servlet\n\td)\tJSP是Java和HTML组合成的一个扩展名为.jsp的文件\n十、\tServlet中的转发（Forword）和重定向(Redirect)有什么区别？\n\n\ta)\t转发是一个请求的延续（1个请求），可以共享request的数据\n\tb)\t重定向是开始一个新的请求，（2个请求），不可以共享request数据\n\tc)\t地址栏：转发地址栏不发生变化，重定向地址栏是会变化的\n十一、\tCookie和Session的区别？\n\t\n\ta)\t存储位置：Cookie存在浏览器，Session存储在服务器\n\tb)\t安全角度：cookie不安全，session安全\n\tc)\t数据量：  cookie不可以存大数据，session可以存大数据，重要数据等.\n十二、\tHttp中get和post的 区别\n\t\n\ta)\t在客户端：Get方式在通过URL提交数据，数据在URL可以看到,POST方式，数据放置在HTML HEADER内提交\n\tb)\tGet方法提交的数据最多只有1024字节，post则没有限制\n\tc)\tGet不安全，Post安全\n十三、\tJSP有哪些内置对象？\n\n\ta)\tRequest  response out\t\t\t\t: 输入输出对象\n\tb)\tSession application pageContext\t\t：作用域通信对象\n\tc)\tPage config\t\t\t\t\t\t\t：Servlet对象\n\td)\tException\t\t\t\t\t\t\t：异常对象\n十四、\tJSP乱码如何解决？\n\t\n\ta)\t3种方法\n\t\t1.\tJSP页面乱码：<%@page contentType=”text/html;charset=utf-8”%>\n\t\t2.\t表单提交中文时候出现的乱码：request.setCharacterEncoding(“utf-8”);\n\t\t3.\t数据库连接出现乱码：\tuseUnicode=true&characterEncoding=utf-8;\n\n\n\n\n","tags":["面试资料"],"categories":["interview"]},{"title":"Java面试资料","url":"/2018/06/23/面试题Java基础/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n<The rest of contents | 余下全文>\n\n>*一、\t继承的好处和弊端是什么？*\n\n\t（什么是继承：继承是一种连接的层次模型，鼓励类的重用）\n\ta)\t好处是：提高代码复用性，维护性，让类与类之间产生了关系，是多态的前提。\n\tb)\t弊端是：类的耦合性增强了，java开发的宗旨是高复用，低耦合。\n二、\tJava中继承的特点是什么？\n\n\ta)\tJava只支持单继承，不支持多继承。\n\tb)\t子类不能继承父类私有的属性和方法\n\tc)\t子类不能继承父类的构造方法，但是可以通过super关键字去访问父类的构造方法。\n\td)\t注意不要为了部分功能去继承。\n三、\t重写和重载的区别是什么？\n\n\ta)\t重载：是发生在同一个类中，在该类中如果存在多个同名方法，但是方法的参数列表不同，那么就说明该方法被重载了。（方法名相同，参数列表不同）。\n\tb)\t重写：是发生在子类继承父类的关系中，父类的方法被子类继承，方法名，返回值类型，参数完全是一样的，但是方法体不一样，那么就说明父类的该方法被子类重写了（方法名，参数列表相同，方法体不同）\n四、\tJava 中的final关键字有哪些用法？ \n\n\ta)\t修饰类：表示该类不能被继承；\n\tb)\t修饰方法：表示方法不能被重写；\n\tc)\t修饰变量：表示变量只能一次赋值以后值不能被修改（常量）。\n五、\t阐述final、finally、finalize的区别。\n\n\ta)\tfinal:\t\t是一个修饰符号\n\tb)\tfinally:\t是跟在try/catch组合后面的，一般用于关闭资源，关闭连接\n\tc)\tfinalize:\tObject类中定义的方法，Java中允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。\n\t \t\t\t这个方法是由垃圾收集器在销毁对象时调用的，通过重写finalize()方法可以整理系统资源或者执行其他清理工作。\n六、\t成员变量和局部变量的区别？\n\t\n\ta)\t成员变量作用于整个类中，存放在内存的堆区。在这个类有效。存于堆中，随着对象产生而存在，消失而消失。\n\tb)\t局部变量作用于方法中，参数上，语句中  存放在内存的栈区，随着所属区域的运行而存在，结束而释放。\n七、\t实例变量和静态变量的区别？\n\n\ta)\t语法上的区别是静态变量前面要加static，实例变量则不用。\n\tb)\t实例变量需要通过创建对象来调用。\n\tc)\t静态变量是由static修饰的变量，可以由类名直接调用，也叫类变量。\n八、\t是否可以从一个静态方法中调用非静态方法？\n\n\ta)\t不可以，因为非静态方法要与对象关联起来，必须创建一个对象后，才可以在该对象上进行方法调用，而static方法调用时不需要创建对象。\n九、\t什么是内部类？作用是什么？内部类有几种？\n\n\ta)\t包裹在外部类的叫做内部类。\n\tb)\t作用是4种：\n\t\t1.\t内部类可以很好的实现隐\n\t\t2.\t内部类拥有外部类的所有元素的访问权限\n\t\t3.\t内部类可以实现多重继承\n\t\t4.\t可以避免修改接口而实现同一个类中两种方法的调用。\n\tc)\t有4种内部类：\n\t\t1.\t成员内部类\n\t\t2.\t局部内部类\n\t\t3.\t匿名内部类\n\t\t4.\t静态内部类\n十、\t构造器可不可以重写？\n\n\t\ta)\t不可以，因为构造器不能被继承，所以不能被重写，但是可以被重载。\n十一、\tError和exception有什么区别？\n\n\ta)\tError表示不是不可能但是很困难恢复情况下的一种问题，比如说内存溢出，服务器宕机等。\n\tb)\tException表示一种设计或实现问题，也就是说，如果程序正常，它是绝对不会出现的问题。\n\n十二、\t列出一些你常见的运行时异常？\n\n\t- ArithmeticException\t\t（算术异常） \n\t- ClassCastException \t\t（类转换异常） \n\t-IllegalArgumentException  （非法参数异常） \n\t-IndexOutOfBoundsException （下标越界异常） \n\t- NullPointerException \t\t（空指针异常） \n\t- SecurityException \t\t（安全异常）\n十三、\t接口和抽象类的区别？\n\n\ta)\t构造方法：抽象类有，接口没有\n\tb)\t成员变量：抽象类有，接口没有\n\tc)\t普通方法：抽象类有，接口没有\n\td)\t静态方法：抽象类有，接口没有\n\te)\t访问类型：public protected private  接口：public\n\tf)\t一个类可以实现多个接口，但只能继承一个抽象类。\n十四、\t创建线程有几种方式？分别是什么？\n\n\ta)\t2种：\n\t1.\t继承Thread类\n\t2.\t实现Runnable接口\n\tb)\t补充：Java 5以后创建线程还有第三种方式：实现Callable接口，该接口中的call方法可以在线程执行结束时产生一个返回值 \n十五、\t创建线程时继承Thread类和实现Runnable接口有什么异同，推荐使用那一种？\n\n\ta)\t同：都有重写run方法来定义线程行为。\n\tb)\t推荐使用后者：因为java中的继承是单一继承，显然使用Runnable更加灵活。\n十六、\t启动一个线程是调用run()还是start()方法？ \n\n\ta)\t用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM 调度并执行，\n\t这并不意味着线程就会立即运行。run()方法是线程启动后要进行回调（callback）的方法。\n十七、\t线程的生命周期？\n\t\n\ta)\t5个阶段：\n\t\t1.\t新建  (new Thread)：\t当创建Thread类的一个实例（对象）时，此线程进入新建状态（未被启动）Thread t1 = new Thead();\t\n\t\t2.\t就绪\t(runnable)：\t线程已经被启动，正在等待被分配给CPU时间片，也就是说此时线程正在就绪队列中排队等候得到CPU资源，\n\t\t3.\t运行\t (running)：\t线程获得CPU资源正在执行任务（run()方法），此时除非此线程自动放弃CPU资源或者有优先级更高的线程进入，线程将一直运行到结束。\n\t\t4.\t阻塞\t (blocked)：\t由于某种原因导致正在运行的线程让出CPU并暂停自己的执行，即进入阻塞状态。\n\t\t5.\t死亡\t   (dead)：\t当线程执行完毕或者被其他线程杀死，线程就进入死亡状态，这时线程不可能再进入就绪状态等待执行。\n十八、\t请说出与线程同步以及线程调度相关的方法？\n\t\n\ta)\t wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁； \n\tb)\t sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理InterruptedException异常；\n\tc)\t notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关； \n\td)\t notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；\n十九、\t线程的sleep()方法和wait()有什么区别？\n\n\ta)\tSleep：休眠，线程的静态方法。将CPU时间片让给其他线程，但是对象锁依然保持，所以休眠时间结束后会自动恢复。\n\tb)\tWait：等待，会导致当前线程放弃对象的锁，让线程进入等待池，只有调用对象的notify()方法，\n\t（或者notifyAll()方法）时候才能唤醒等待池中的线程进入等锁池，如果线程重新获得对象的锁就可以进入就绪状态。\n二十、\tList、Set、Map是否都继承与collection接口？\n\n\ta)\t不全是，List/Set是，Map不是。\n二十一、\tList、Set、Map有什么区别？\n\n\ta)\tList：\t有序可重复  可迭代器遍历\n\tb)\tSet：\t无序不重复\t可迭代器遍历\n\tc)\tMap：\t键值对形式，无序，Key不可重复，Value可以重复\t先遍历Key再遍历Value\n二十二、\tHashMap和HashTable的区别？\n\t\n\ta)\tHashMap是HashTable的轻量级实现。\n\tb)\t线程安全：\t\tHashTable 安全，HashMap不安全\n\tc)\t执行效率：\t\tHashTable慢，HashMap快\n\td)\t对Null存储：\tHashTable不允许，HashMap允许存NULL键值对\n二十三、\tJava有几种类型的流？分别继承于什么？\n\n\ta)\t2种：\n\t\t1.\t字节流：继承于：InputStream/OutputStream\n\t\t2.\t字符流：继承于：Reader/Writer\n二十四、\tString  StringBuilder  StringBuffer的区别？\n\n\ta)\tString是由final所修饰的类，所以String是不可变的字符串常量，使用字符串拼接时是不同的两个空间。\n\tb)\tStringBuffer是可以改变的字符串变量，可以通过append直接在字符串后面追加，是线程安全的\n\tc)\tStringBuffer是可以改变的字符串变量，可以通过append直接在字符串后面追加，是线程不安全的\n\td)\t执行效率StringBuffer执行效率最高。\n二十五、\t阐述JDBC操作数据库的步骤。 \n\n\ta)\t分5步：\n\t\t1.\t加载驱动\n\t\t2.\t创建连接\n\t\t3.\t创建语句\n\t\t4.\t执行语句\n\t\t5.\t处理结果\n\t\t6.\t关闭资源\n二十六、\tStatement和PreparedStatement有什么区别？哪个性能更好？\n\t\n\ta)\tPreparedStatement可减少SQL编译错误，增加SQL安全性，也就是放在SQL注入攻击。\n\tb)\t当批量处理SQL或频繁执行相同的查询时，PreparedStatement有明显的性能更快。\n\n二十七、\t什么是SQL注入攻击？\n\t\n\ta)\t就是攻击者把SQL命令插入到Web表单的输入域或页面请求的查询字符串，欺骗服务器执行恶意的SQL命令\n二十八、\t请简述你了解的几个排序方法，最少说出3个，并写出其中一个？\n\n\ta)\t冒泡排序，选择排序，插入排序，希尔排序\n二十九、\t什么是事务？事务的ACID四个特性分别是什么？举个生活当中的例子说明下什么是事务？\n\n\ta)\t事务就是指作为单个逻辑工作单元执行的一系列操作，同步发生数据更新时，防止数据的不一致。\n\tb)\tACID：\n\t\t1.\t 原子性(Atomic)：\t\t事务中各项操作，要么全做要么全不做，任何一项操作的失败都会导致整个事务的失败； \n\t\t2.\t 一致性(Consistent)：\t事务结束后系统状态是一致的； \n\t\t3.\t 隔离性(Isolated)：\t\t并发执行的事务彼此无法看到对方的中间状态；\n\t\t4.\t 持久性(Durable)：\t\t事务完成后所做的改动都会被持久化，即使发生灾难性的失败。通过日志和同步备份可以在故障发生后重建数据。\n三十、\t什么是索引？如何创建索引？举个生活中的例子来诠释索引？\n\t\n\ta)\t索引是一种可以直接访问数据库表中某一数据行的树型结构，为了提高查询效率而引入的，是独立与表的对象。\n\tb)\tCreate index 索引名\n\n\n一、\tJSP技术优缺点？\na)\t优点：\n1.\tJSP代码跨平台\n2.\tJSP组件跨平台\n3.\t支持多种网页格式\n4.\tJSP标签可扩充性\nb)\t缺点：\n1.\tJSP技术极大的增加了产品的复杂性。\n2.\tJSP程序调试很困难\n二、\t\nweb.xml文件中可以配置哪些内容？\na)\tweb.xml用于配置Web应用的相关信息，如：监听器（listener）、过滤器（filter）、 Servlet、相关参数、会话超时时间、安全验证方式、错误页面等。\n\n","tags":["面试资料"],"categories":["interview"]},{"title":"WebStrom快捷键","url":"/2017/10/30/软件WebStrom快捷键/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\nWebStrom快捷键\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\tCtrl+/ 或 Ctrl+Shift+/-----------------------------------------------注释（// 或者/*…*/ ）\n\tShift+F6-------------------------------------------------------------重构-重命名\n\tCtrl+X-------------------------------------------------------------- 删除行\n\tCtrl+D---------------------------------------------------------------复制行\n\tCtrl+G---------------------------------------------------------------查找行\n\tCtrl+Shift+Up/Down---------------------------------------------------代码向上/下移动。\n\tF2 或Shift+F2---------------------------------------------------------高亮错误或警告快速定位\n\t写代码，按Tab----------------------------------------------------------生成代码\n\t选中文本，按Ctrl+Shift+F7------------------------------------------高亮显示所有该文本，按Esc高亮消失。(因为这个功能我就可以发放心的放弃sublime了)\n\tCtrl+B或Ctrl+鼠标左键单击------------------------------------------快速打开光标处的类或方法，（NB的功能）\n\tCtrl + Alt + B\t-------------------------------------------------Go to implementation(s) 跳转方法实现处\n\tCtrl + Shift + I\t---------------------------------------------Open quick definition lookup 打开定义快速查找\n\tAlt + Up/Down\t-------------------------------------------------Go to previous/next method 跳转到上一个/下一个方法\n\tCtrl+E-----------------------------------------------------------最近打开的文件\n\tAlt+F1-----------------------------------------------------------查找代码所在位置\n\tCtrl+Alt+L-------------------------------------------------------格式化代码\n\tCtrl+R-----------------------------------------------------------替换文本\n\tCtrl+F-----------------------------------------------------------查找文本\n\tCtrl+P-----------------------------------------------------------方法参数提示\n\tF3---------------------------------------------------------------查找下一个\n\tShift+F3---------------------------------------------------------查找上一个\n\talt+Shift+F------------------------------------------------------将当前文件加入收藏夹\n\tctrl+alt+s-------------------------------------------------------打开配置窗口\n\tctrl+Shift+N-----------------------------------------------------通过文件名快速查找工程内的文件（必记）\n\tctrl+Shift+alt+N-------------------------------------------------过一个字符快速查找位置（必记）\n\tShift+enter------------------------------------------------------重新开始一行（无论光标在哪个位置）\n\tCtrl + Alt + T----------------------------with…（if, else, try, catch, for, etc）用 * 来围绕选中的代码行，（ * 包括 if 、 while 、 try catch 等）\n\tCtrl + Shift + U-------------------------------------------------Toggle case for word at caret or selected block 光标所在位置大小写\n\tCtrl + Delete----------------------------------------------------Delete to word end 删除文字结束\n\tCtrl + Backspace-------------------------------------------------Delete to word start 删除文字开始\n\tCtrl + E---------------------------------------------------------Recent files popup 弹出最近打开的文件\n\tF11\tToggle bookmark----------------------------------------------切换标记，我觉得叫书签更好，就是sublime text 的F2\n\tCtrl + Shift + F12-----------------------------------------------Toggle maximizing editor 切换最大化编辑器\n\tAlt + Shift + F--------------------------------------------------Add to Favorites 添至收藏夹","tags":["WebStrom"],"categories":["tool"]},{"title":"IDEA快捷键","url":"/2017/10/30/软件Intellij IDEA 快捷键整理/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\nIDEA快捷键\n<!-- more -->\n<The rest of contents | 余下全文>\n【常规】\n\n\tCtrl+Shift + Enter，语句完成\n\t“！”，否定完成，输入表达式时按 “！”键\n\tCtrl+E，最近的文件\n\tCtrl+Shift+E，最近更改的文件\n\tShift+Click，可以关闭文件\n\tCtrl+[ OR ]，可以跑到大括号的开头与结尾\n\tCtrl+F12，可以显示当前文件的结构\n\tCtrl+F7，可以查询当前元素在当前文件中的引用，然后按 F3 可以选择\n\tCtrl+N，可以快速打开类\n\tCtrl+Shift+N，可以快速打开文件\n\tAlt+Q，可以看到当前方法的声明\n\tCtrl+P，可以显示参数信息\n\tCtrl+Shift+Insert，可以选择剪贴板内容并插入\n\tAlt+Insert，可以生成构造器/Getter/Setter等\n\tCtrl+Alt+V，可以引入变量。例如：new String();  自动导入变量定义\n\tCtrl+Alt+T，可以把代码包在一个块内，例如：try/catch\n\tCtrl+Enter，导入包，自动修正\n\tCtrl+Alt+L，格式化代码\n\tCtrl+Alt+I，将选中的代码进行自动缩进编排，这个功能在编辑 JSP 文件时也可以工作\n\tCtrl+Alt+O，优化导入的类和包\n\tCtrl+R，替换文本\n\tCtrl+F，查找文本\n\tCtrl+Shift+Space，自动补全代码\n\tCtrl+空格，代码提示（与系统输入法快捷键冲突）\n\tCtrl+Shift+Alt+N，查找类中的方法或变量\n\tAlt+Shift+C，最近的更改\n\tAlt+Shift+Up/Down，上/下移一行\n\tShift+F6，重构 - 重命名\n\tCtrl+X，删除行\n\tCtrl+D，复制行\n\tCtrl+/或Ctrl+Shift+/，注释（//或者/**/）\n\tCtrl+J，自动代码（例如：serr）\n\tCtrl+Alt+J，用动态模板环绕\n\tCtrl+H，显示类结构图（类的继承层次）\n\tCtrl+Q，显示注释文档\n\tAlt+F1，查找代码所在位置\n\tAlt+1，快速打开或隐藏工程面板\n\tCtrl+Alt+left/right，返回至上次浏览的位置\n\tAlt+left/right，切换代码视图\n\tAlt+Up/Down，在方法间快速移动定位\n\tCtrl+Shift+Up/Down，向上/下移动语句\n\tF2 或 Shift+F2，高亮错误或警告快速定位\n\tTab，代码标签输入完成后，按 Tab，生成代码\n\tCtrl+Shift+F7，高亮显示所有该文本，按 Esc 高亮消失\n\tAlt+F3，逐个往下查找相同文本，并高亮显示\n\tCtrl+Up/Down，光标中转到第一行或最后一行下\n\tCtrl+B/Ctrl+Click，快速打开光标处的类或方法（跳转到定义处）\n\tCtrl+Alt+B，跳转到方法实现处\n\tCtrl+Shift+Backspace，跳转到上次编辑的地方\n\tCtrl+O，重写方法\n\tCtrl+Alt+Space，类名自动完成\n\tCtrl+Alt+Up/Down，快速跳转搜索结果\n\tCtrl+Shift+J，整合两行\n\tAlt+F8，计算变量值\n\tCtrl+Shift+V，可以将最近使用的剪贴板内容选择插入到文本\n\tCtrl+Alt+Shift+V，简单粘贴\n\tShift+Esc，不仅可以把焦点移到编辑器上，而且还可以隐藏当前（或最后活动的）工具窗口\n\tF12，把焦点从编辑器移到最近使用的工具窗口\n\tShift+F1，要打开编辑器光标字符处使用的类或者方法 Java 文档的浏览器\n\tCtrl+W，可以选择单词继而语句继而行继而函数\n\tCtrl+Shift+W，取消选择光标所在词\n\tAlt+F7，查找整个工程中使用地某一个类、方法或者变量的位置\n\tCtrl+I，实现方法\n\tCtrl+Shift+U，大小写转化\n\tCtrl+Y，删除当前行\n\tShift+Enter，向下插入新行\n\tpsvm/sout，main/System.out.println(); Ctrl+J，查看更多\n\tCtrl+Shift+F，全局查找\n\tCtrl+F，查找/Shift+F3，向上查找/F3，向下查找\n\tCtrl+Shift+S，高级搜索\n\tCtrl+U，转到父类\n\tCtrl+Alt+S，打开设置对话框\n\tAlt+Shift+Inert，开启/关闭列选择模式\n\tCtrl+Alt+Shift+S，打开当前项目/模块属性\n\tCtrl+G，定位行\n\tAlt+Home，跳转到导航栏\n\tCtrl+Enter，上插一行\n\tCtrl+Backspace，按单词删除\n\tCtrl+\"+/-\"，当前方法展开、折叠\n\tCtrl+Shift+\"+/-\"，全部展开、折叠\n\n【调试部分、编译】\n\n\tCtrl+F2，停止\n\tAlt+Shift+F9，选择 Debug\n\tAlt+Shift+F10，选择 Run\n\tCtrl+Shift+F9，编译\n\tCtrl+Shift+F10，运行\n\tCtrl+Shift+F8，查看断点\n\tF8，步过\n\tF7，步入\n\tShift+F7，智能步入\n\tShift+F8，步出\n\tAlt+Shift+F8，强制步过\n\tAlt+Shift+F7，强制步入\n\tAlt+F9，运行至光标处\n\tCtrl+Alt+F9，强制运行至光标处\n\tF9，恢复程序\n\tAlt+F10，定位到断点\n\tCtrl+F8，切换行断点\n\tCtrl+F9，生成项目\n\tAlt+1，项目\n\tAlt+2，收藏\n\tAlt+6，TODO\n\tAlt+7，结构\n\tCtrl+Shift+C，复制路径\n\tCtrl+Alt+Shift+C，复制引用，必须选择类名\n\tCtrl+Alt+Y，同步\n\tCtrl+~，快速切换方案（界面外观、代码风格、快捷键映射等菜单）\n\tShift+F12，还原默认布局\n\tCtrl+Shift+F12，隐藏/恢复所有窗口\n\tCtrl+F4，关闭\n\tCtrl+Shift+F4，关闭活动选项卡\n\tCtrl+Tab，转到下一个拆分器\n\tCtrl+Shift+Tab，转到上一个拆分器\n\n【重构】\n\n\tCtrl+Alt+Shift+T，弹出重构菜单\n\tShift+F6，重命名\n\tF6，移动\n\tF5，复制\n\tAlt+Delete，安全删除\n\tCtrl+Alt+N，内联\n\n【查找】\n\n\tCtrl+F，查找\n\tCtrl+R，替换\n\tF3，查找下一个\n\tShift+F3，查找上一个\n\tCtrl+Shift+F，在路径中查找\n\tCtrl+Shift+R，在路径中替换\n\tCtrl+Shift+S，搜索结构\n\tCtrl+Shift+M，替换结构\n\tAlt+F7，查找用法\n\tCtrl+Alt+F7，显示用法\n\tCtrl+F7，在文件中查找用法\n\tCtrl+Shift+F7，在文件中高亮显示用法\n\n【VCS】\n\n\tAlt+~，VCS 操作菜单\n\tCtrl+K，提交更改\n\tCtrl+T，更新项目\n\tCtrl+Alt+Shift+D，显示变化","tags":["IDEA"],"categories":["tool"]},{"title":"HTTP状态码说明","url":"/2017/10/30/HTTP状态码说明/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\nHTTP状态码说明\n<!-- more -->\n<The rest of contents | 余下全文>\n\nHTTP状态码（HTTP Status Code）是用以表示网页服务器HTTP响应状态的3位数字代码。当我们打开一个网页时，如果网页能够返回数据，也就是说影响成功了，一般状态响应码都是200。当然状态响应码，包括很多内容，下面列举了，状态响应码，及其表示的含义:\n\n\n\n\t100：继续 客户端应当继续发送请求。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。\n\t101： 转换协议 在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。只有在切换新的协议更有好处的时候才应该采取类似措施。\n\t102：继续处理 由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。\n\t200：请求成功 处理方式：获得响应的内容，进行处理 \n\t201：请求完成，结果是创建了新资源。新创建资源的URI可在响应的实体中得到 处理方式：爬虫中不会遇到 \n\t202：请求被接受，但处理尚未完成 处理方式：阻塞等待 \n\t204：服务器端已经实现了请求，但是没有返回新的信 息。如果客户是用户代理，则无须为此更新自身的文档视图。 处理方式：丢弃 \n\t300：该状态码不被HTTP/1.0的应用程序直接使用， 只是作为3XX类型回应的默认解释。存在多个可用的被请求资源。 处理方式：若程序中能够处理，则进行进一步处理，如果程序中不能处理，则丢弃 \n\t301：请求到的资源都会分配一个永久的URL，这样就可以在将来通过该URL来访问此资源 处理方式：重定向到分配的URL \n\t302：请求到的资源在一个不同的URL处临时保存 处理方式：重定向到临时的URL \n\t304：请求的资源未更新 处理方式：丢弃 \n\t400：非法请求 处理方式：丢弃 \n\t401：未授权 处理方式：丢弃 \n\t403：禁止 处理方式：丢弃 \n\t404：没有找到 处理方式：丢弃 \n\t500：服务器内部错误 服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器端的源代码出现错误时出现。 \n\t501：服务器无法识别 服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。 \n\t502：错误网关 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。 \n\t503：服务出错 由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。","tags":["HTTP状态码说明"],"categories":["servicer"]},{"title":"JDBC","url":"/2017/10/30/数据库JDBC/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\nJDBC\n<!-- more -->\n<The rest of contents | 余下全文>\n##JDBC\n###什么是JDBC\n- Java DataBase Connectivity,java数据库连接，实际上jdbc是java中的一套和数据库交互的api（application program interface 应用程序编程接口）\n###为什么使用JDBC\n![](01.png)\n- 因为java程序员需要连接多种数据库(orcale,mysql,db2等)为了避免每一个数据库都学习一套新的api，sun公司提出了一个jdbc接口，各个数据库厂商根据此接口写实现类（驱动）,这样java程序员只需要掌握JDBC接口中的一套方法，就可以访问任何数据库。\n###如何使用JDBC\n1. 创建maven工程\n2. 下载mysql相关jar包\n\n\t登陆达内的私服：maven.tedu.cn\n\n\t登陆阿里私服：maven.aliyun.com\n\n\t- 首页搜索栏输入mysql 搜索\n\t- 找到5.1.6版本 复制坐标 到自己工程的pom.xml文件里\n3. 创建JDBCDemo1.java类 添加main方法\n4. 使用步骤：\n\t- 注册驱动\n\t- 获取连接对象\n\t- 创建sql执行对象\n\t- 执行sql语句\n\t- 关闭资源\n\n            //1.注册驱动\n            Class.forName(\"com.mysql.jdbc.Driver\");\n            //2.获取连接对象\n            Connection conn = DriverManager.getConnection( \"jdbc:mysql://localhost:3306/db3\", \"root\", \"root\");\n            //3.创建sql执行对象\n            Statement stat = conn.createStatement();\n            //4.执行sql\n            stat.execute(\"drop table if exists jdbct2\");\n            System.out.println(\"删除成功！\");\n            //5. 关闭资源\n            stat.close();\n            conn.close();\n\n####执行sql的方法\n- execute(sql) 可以执行任意sql，但是推荐执行DDL\n\t返回值为boolean值 true代表有结果集 false代表没有结果集，成功或失败通过是否有异常来判断\n- executeUpdate(sql) 推荐执行DML\n\t返回值为int 代表生效行数\n- executeQuery(sql)推荐执行DQL\n\n\tinsert into jdbct1 values(2,'Jerry'),(3,'李白');\n\n\t返回值ResultSet 里面装了查询结果\n\tnext()方法的作用：判断有没有下一条数据有返回值为true（同时游标往下移动） 没有则false\n\n\t\t\t//4.执行sql\n\t\t\t\tResultSet rs =stat.executeQuery(\"select * from jdbct1\");\n\t\t\t\t\t//遍历结果\n\t\t\t\t\twhile(rs.next()){\n\t\t\t\t\t\tint id = rs.getInt(\"id\");\n\t\t\t\t\t\tString name = rs.getString(\"name\");\n\t\t\t\t\t\tSystem.out.println(id+\":\"+name);\n\t\t\t\t\t}\n\n###数据库类型和Java类型对比\n\t\tmysql            \t java\n\t\tint             \t getInt\n\t\tvarchar           \t getString\n\t\tfloat/double    \t getFloat/getDouble\n\t\tdatetime/timestamp   getDate\n###ResultSet获取数据的方式\n1. 通过字段名获取  如：getString(\"name\")\n2. 通过查询到结果数据的位置获取 如：getString(2); 位置从1开始\n\n###读取配置文件\n        //创建读取配置文件的对象\n\t\tProperties prop = new Properties();\n\t\t//获取文件输入流\n\t\tInputStream ips =DBUtils.class.getClassLoader().getResourceAsStream(\"jdbc.properties\");\n\t\t//把文件加载到对象中\n\t\ttry {\n\t\t\tprop.load(ips);\n\t\t\t//读取连接数据库的信息\n\t\t\tdriver = prop.getProperty(\"driver\");\n\t\t\turl = prop.getProperty(\"url\");\n\t\t\tusername = prop.getProperty(\"username\");\n\t\t\tpassword = prop.getProperty(\"password\");\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n###数据库连接池\n- DBCP DataBase Connection Pool:数据库连接池\n- 为什么使用：如果没有连接池，每一次业务都需要和数据库服务器建立一次连接，业务处理完断开连接，如果有上万次业务就会有上万次的开关连接，频繁开关连接非常浪费资源，使用数据库连接池，可以设置几个初始连接，如果有业务需要使用连接，则从连接池中直接获取，如果连接池中连接用光，则会等待连接归还后再获取连接\n\n- 如何使用：\n1. 下载jar包： 从maven私服中搜索 dbcp\n\n2. 代码：\n\n\n\t\tdataSource.setDriverClassName(\"com.mysql.jdbc.Driver\");\n\t\tdataSource.setUrl(\"jdbc:mysql://localhost:3306/db3\");\n\t\tdataSource.setUsername(\"root\");\n\t\tdataSource.setPassword(\"root\");\n\t\t//3. 设置连接池策略信息\n\t\tdataSource.setInitialSize(3);//初始连接数量\n\t\tdataSource.setMaxActive(5);//最大连接数量\n\n\t\t//4.从连接池中获取连接对象\n\t\tConnection conn = dataSource.getConnection();\n\t\tSystem.out.println(conn);\n\n\n###解决jdbc乱码问题\n\n在url后面添加如下内容\n\n    jdbc:mysql://localhost:3306/db3?useUnicode=true&characterEncoding=UTF-8\n\n\n\n###Properties属性配置文件\n- 代码参见：demo03.java\n\n###PreparedStatement\n- 好处：\n1. 相比较Statement 代码结构整齐，可读性高。\n2. 可以避免SQL注入，因为在编译的时候已经把SQL的逻辑固定，替换？时如果有修改逻辑的语句如or 则不会生效 \n3. 如果执行大量的SQL语句 preparedstatement 执行效率略高于statement\n\n- 如果SQL中有变量则使用preparedStatement，没有变量则可以使用statement\n\n###批量操作\n- 代码参见：demo06.java  demo07.java\n\n###分页查询\n- 代码参见：demo08.java\n\n###事务 \n- 代码参见：demo09.java\n\n###获取自增主键值\n\n###乱码问题\n在url后面添加以下内容\njdbc:mysql://localhost:3306/db3?useUnicode=true&characterEncoding=UTF-8\n\n\n###元数据\n- 数据库元数据: 一些和数据库相关的信息如：数据库版本信息，数据库厂商等\n- 表元数据: 一些和表相关的信息：表字段的数量，字段名称，字段类型等\n","tags":["JDBC"],"categories":["after-end"]},{"title":"Excel","url":"/2017/10/30/excel/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\nExcel\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\t\n\t性别:IF(MOD(B9,17,1),2)=1,\"男\",\"女\")\n\t生日:TEXT(MOD(B9,7,8),\"0000-00-00\")","tags":["Excel"],"categories":["assist"]},{"title":"Linux查看系统配置常用命令","url":"/2017/10/30/Linux查看系统配置常用命令/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\nLinux查看系统配置常用命令\n<!-- more -->\n<The rest of contents | 余下全文>\n\n**系统**\n\n\t\t head -n 1 /etc/issue    查看操作系统版本\n\t\t cat /proc/cpuinfo       查看CPU信息\n\t\t hostname                查看计算机名\n\t\t lspci -tv               列出所有PCI设备\n\t\t lsusb -tv               列出所有USB设备\n\t\t lsmod                   列出加载的内核模块\n\t\t env                     查看环境变量\n\n**资源**\n\n\t\t free -m                 查看内存使用量和交换区使用量\n\t\t df -h                   查看各分区使用情况\n\t\t du -sh <目录名>          查看指定目录的大小\n\t\t grep MemTotal /proc/meminfo    查看内存总量\n\t\t grep MemFree /proc/meminfo     查看空闲内存量\n\t\t uptime                  查看系统运行时间、用户数、负载\n\t\t cat /proc/loadavg       查看系统负载\n\n**磁盘和分区**\n\n\t\t mount | column -t       查看挂接的分区状态\n\t\t fdisk -l                查看所有分区\n\t\t swapon -s               查看所有交换分区\n\t\t hdparm -i /dev/hda      查看磁盘参数(仅适用于IDE设备)\n\t\t dmesg | grep IDE        查看启动时IDE设备检测状况\n\n**网络**\n\n\t\t ifconfig                查看所有网络接口的属性\n\t\t iptables -L             查看防火墙设置\n\t\t route -n                查看路由表\n\t\t netstat -lntp           查看所有监听端口\n\t\t netstat -antp           查看所有已经建立的连接\n\t\t netstat -s              查看网络统计信息\n\n**进程**\n\n\t\tps -ef                  查看所有进程\n\t\ttop                     实时显示进程状态\n\n**用户**\n\n\t\t w                     \t    查看活动用户\n\t\t id <用户名>           \t  查看指定用户信息\n\t\t last                   \t查看用户登录日志\n\t\t cut -d: -f1 /etc/passwd    查看系统所有用户\n\t\t cut -d: -f1 /etc/group     查看系统所有组\n\t\t crontab -l                 查看当前用户的计划任务\n\n**服务**\n\n\t\t chkconfig --list              列出所有系统服务\n\t\t chkconfig --list | grep on    列出所有启动的系统服务\n\n**程序**\n\n\t\trpm -qa                        查看所有安装的软件包","tags":["Linux"],"categories":["servicer"]}]